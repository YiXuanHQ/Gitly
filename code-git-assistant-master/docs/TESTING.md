# Git Assistant 项目验证和调试指南

> **当前版本**：v1.0.2 | **最后更新**：2025-12-11

本指南帮助你快速验证 Git Assistant 扩展是否工作正常，并在出现问题时提供排查路径。

# 1. 前置检查

### 1.1 环境版本

在开始之前，确认以下工具版本满足要求：

+ **Node.js 16+**

```powershell
node --version
```

+ **npm**

```powershell
npm --version
```

+ **Git**

```powershell
git --version
```

+ **VS Code 1.80+**

```powershell
code --version
```

### 1.2 安装依赖

```powershell
cd E:\CodeGitAssistant
npm install
```

预期输出：`added XXX packages ...`

若安装失败，可尝试：

```powershell
Remove-Item node_modules -Recurse -Force
Remove-Item package-lock.json -Force
npm install
```

### 1.3 编译项目

+ **单次编译**

```powershell
npm run compile
```

+ **监听模式（推荐开发时使用）**

```powershell
npm run watch
```

预期输出：

```plain
webpack 5.x.x compiled successfully in xxx ms
asset extension.js xxx KiB [emitted]
asset webview.js xxx KiB [emitted]
```

出现错误时可追加 `--display-error-details` 查看细节：

```powershell
npm run compile -- --display-error-details
```

### 1.4 启动调试

+ **方法 A：VS Code（推荐）**
  1. 在 VS Code 中打开 `E:\CodeGitAssistant`
  2. 终端运行 `npm run watch`
  3. 按 `F5`（或菜单：运行 → 启动调试）
  4. 弹出 `[Extension Development Host]` 窗口
+ **方法 B：使用 **`launch.json``.vscode/launch.json` 已配置：

```json
{
  "name": "运行扩展",
  "type": "extensionHost",
  "request": "launch",
  "args": ["--extensionDevelopmentPath=${workspaceFolder}"]
}
```

# 2. 功能验证

## 2.1 准备测试仓库

```powershell
mkdir E:\TestRepo
cd E:\TestRepo
git init
echo "# Test" > README.md
git add .
git commit -m "Initial commit"
code .
```

## 2.2 验证扩展激活

+ `Ctrl+Shift+X` → 搜索 **Git Assistant** → 显示“已启用”
+ `Ctrl+Shift+U` → 选择 **Git Assistant** 输出通道 → 日志显示“扩展已激活”

## 2.3 验证侧边栏

+ 分支管理
+ 提交历史
+ 冲突检测

## 2.4 测试快捷键

| 快捷键       | 功能     | 预期结果               |
| ------------ | -------- | ---------------------- |
| `Ctrl+Alt+P` | 快速推送 | 弹出推送确认对话框     |
| `Ctrl+Alt+L` | 快速拉取 | 开始拉取操作           |
| `Ctrl+Alt+B` | 切换分支 | 显示分支列表并进行切换 |


**场景化验证**

1. **快速推送（Ctrl+Alt+P）**
   - 在当前分支制造一次提交：`git commit -am "shortcut push"`
   - 按下快捷键后确认弹窗中显示目标远程与分支信息
   - 在弹窗中选择“确认推送”，查看输出面板应出现“开始推送/推送成功”日志，并在侧边栏提交历史中看到该提交被标记为已同步
2. **快速拉取（Ctrl+Alt+L）**
   - 在远程仓库制造一条新提交（可在另一终端 `git commit && git push`）
   - 回到 VS Code，确保当前分支有对应远程追踪
   - 按下快捷键，观察通知提示“正在拉取”，完成后刷新提交历史/时间线视图确认新增提交已同步
   - 若产生冲突，输出面板与“冲突检测”视图应立即出现红色提示
3. **快速切换分支（Ctrl+Alt+B）**
   - 在 Git Assistant 侧边栏确认存在至少两个分支，如 `main` 与 `feature/shortcut-tests`
   - 按下快捷键，确认弹出的分支列表默认聚焦当前分支，可通过关键字实时过滤
   - 选择目标分支后，状态栏与控制面板“分支管理”标签页应立即更新，同时若新分支存在未提交更改，应弹出提醒
   - 使用 `git status` 验证工作区保持干净，确保切换过程中未残留临时文件

## 2.5 测试命令面板

> **测试目标**：验证所有 Git Assistant 命令在命令面板中正确注册、可被搜索并能正常执行。

### 2.5.1 命令列表完整性验证

`Ctrl+Shift+P` → 输入"Git Assistant" → 应展示全部命令：

| 命令                             | 快捷键       | 预期行为                                     |
| -------------------------------- | ------------ | -------------------------------------------- |
| Git Assistant: 快速推送 (Push)   | `Ctrl+Alt+P` | 弹出推送确认，显示进度，成功/失败通知        |
| Git Assistant: 快速拉取 (Pull)   | `Ctrl+Alt+L` | 检测未提交更改，可选 stash，显示进度         |
| Git Assistant: 克隆仓库 (Clone)  | -            | 输入远程地址，选择目录，显示克隆进度         |
| Git Assistant: 初始化仓库 (Init) | -            | 在当前目录执行 `git init`，成功后刷新视图    |
| Git Assistant: 添加远程仓库      | -            | 输入远程名称和地址，执行 `git remote add`    |
| Git Assistant: 添加文件 (Add)    | -            | 选择一键全部或多选文件，执行 `git add`       |
| Git Assistant: 提交更改 (Commit) | -            | 输入提交信息，执行 `git commit`，可选推送    |
| Git Assistant: 创建分支          | -            | 输入分支名（含校验），执行 `git checkout -b` |
| Git Assistant: 切换分支          | `Ctrl+Alt+B` | 显示分支列表，选择后切换，检测未提交更改     |
| Git Assistant: 合并分支          | -            | 选择目标分支和合并策略（快进/三路）          |
| Git Assistant: 查看提交历史      | -            | 打开历史视图或跳转到控制面板                 |
| Git Assistant: 解决冲突          | -            | 打开冲突解决器或跳转到冲突标签页             |
| Git Assistant: 刷新分支列表      | -            | 刷新侧边栏分支树视图                         |
| Git Assistant: 打开控制面板      | -            | 打开 Webview 控制面板                        |


### 2.5.2 命令搜索与过滤验证

1. **模糊搜索**
   - 输入"push"，验证"Git Assistant: 快速推送"出现在结果中
   - 输入"分支"，验证所有分支相关命令出现
   - 输入"tag"，验证标签相关命令出现
2. **命令图标验证**
   - 验证每个命令有对应的图标（如 `$(cloud-upload)` 对应推送）
   - 图标应清晰可辨，符合语义
3. **命令描述验证**
   - 验证命令标题清晰描述功能
   - 中文标题应准确无歧义

### 2.5.3 命令执行场景验证

1. **Git 仓库内执行**
   - 在已初始化的 Git 仓库中执行各命令
   - 验证命令正常执行，无报错
2. **非 Git 仓库执行**
   - 在非 Git 目录中执行 Git 操作命令（如推送、拉取）
   - 验证弹出提示"当前文件夹不是 Git 仓库"或引导初始化
3. **无远程仓库执行推送**
   - 在没有配置远程的仓库中执行推送
   - 验证弹出提示"当前仓库没有配置远程仓库"
4. **有未提交更改时切换分支**
   - 修改文件但不提交，执行切换分支
   - 验证弹出提示选择：暂存并切换 / 放弃更改并切换 / 取消

### 2.5.4 命令面板验证清单

- [ ] 所有 Git Assistant 命令在命令面板中可见
- [ ] 命令可通过关键字搜索找到
- [ ] 命令图标和标题正确显示
- [ ] 快捷键绑定正确（`Ctrl+Alt+P/L/B`）
- [ ] 非 Git 仓库场景有友好提示
- [ ] 命令执行后有成功/失败反馈

## 2.6 测试控制面板

执行 **Git Assistant: 打开控制面板**，确认：

+ 面板正常加载并显示仓库统计与快捷动作
+ **10 个标签页**顺序为：📋 快捷指令 → 📚 Git 指令集 → ☁️ 远程仓库 → 🌿 分支管理 → 🏷️ 标签管理 → 🧬 Git 视图表 → ⚠️ 冲突解决 → 📊 提交图谱 → 📅 时间线 → 🔥 热力图
+ 各标签内容可加载并可交互

### 2.6.1 测试快捷指令

> **测试目标**：验证快捷指令标签页能有效解决程序员在日常 Git 操作中的常见痛点，如命令记忆困难、重复操作繁琐、执行状态不透明等。

#### 痛点场景 1：界面布局与导航

**问题**：Git 命令众多，新手难以找到需要的功能，老手需要快速定位常用命令。

1. **界面布局验证**
   - 打开控制面板，切换到"📋 快捷指令"标签页（第一个标签）
   - 确认页面包含以下部分：
     * 顶部标题"快捷指令"
     * "🗑️ 清除历史记录"按钮（位于页面右上角）
     * 左侧：命令历史记录区域（显示最近执行的命令）
     * 右侧：可用命令列表区域（按分类折叠/展开显示）
   - **痛点解决**：清晰的布局让用户快速定位历史和可用命令
2. **命令分类显示**
   - 验证以下分类存在并按顺序显示：

| 分类     | 图标 | 包含命令                                   |
| -------- | ---- | ------------------------------------------ |
| 开始使用 | 🚀    | 初始化仓库、克隆仓库                       |
| 配置仓库 | ⚙️    | 添加远程仓库、添加文件、提交更改           |
| 同步操作 | 🔄    | 快速推送、快速拉取                         |
| 分支管理 | 🌿    | 创建分支、切换分支、合并分支               |
| 标签管理 | 🏷️    | 创建标签、查看标签列表、删除标签、推送标签 |
| 查看操作 | 📊    | 查看提交历史、刷新分支列表                 |
| 冲突处理 | ⚠️    | 解决冲突                                   |
| 工具     | 🛠️    | 打开控制面板                               |


    - 默认展开分类：确认"开始使用"和"工具"分类默认展开，其他分类可折叠
        - 点击分类标题验证折叠/展开功能正常
        - **痛点解决**：按功能分类，快速找到需要的命令

3. **命令搜索与过滤（如果有）**
   - 如果提供搜索框，验证：
     * 输入关键字可过滤命令列表
     * 支持中文和英文搜索
     * 搜索结果实时更新
   - **痛点解决**：快速定位特定命令

#### 痛点场景 2：命令可用性智能判断

**问题**：在不同仓库状态下执行不适用的命令会报错，用户需要提前知道哪些命令可用。

1. **非 Git 仓库场景**
   - 在非 Git 目录打开控制面板，验证：
     * "🚀 开始使用"分类中的命令显示为**可用状态**（正常颜色）
     * "⚙️ 配置仓库"及之后分类中的命令显示为**禁用状态**（灰色）
     * 尝试点击禁用命令，确认无响应或提示"请先初始化仓库"
   - **痛点解决**：避免执行无效命令，引导用户先初始化
2. **已初始化但无提交场景**
   - 执行 `git init` 后，验证：
     * "⚙️ 配置仓库"分类的命令变为可用
     * "🔄 同步操作""🌿 分支管理""🏷️ 标签管理"仍为禁用（需要至少一次提交）
   - **痛点解决**：明确告知用户需要先提交
3. **已有提交场景**
   - 创建初始提交后，验证所有需要"commits"的命令变为可用
   - 执行 `git push` 或 `git pull` 后，确认相关命令图标和状态正常
   - **痛点解决**：所有功能解锁，可以正常使用
4. **无远程仓库场景**
   - 在没有配置远程的仓库中，验证：
     * "快速推送""快速拉取"命令显示为禁用或点击时提示配置远程
   - **痛点解决**：避免推送/拉取失败，引导配置远程

#### 痛点场景 3：命令历史记录功能

**问题**：经常需要重复执行相同的 Git 操作，每次都要重新输入参数很繁琐。

1. **执行命令并观察历史**
   - 依次执行以下命令，观察历史记录区域实时更新：
     1. **Git Assistant: 初始化仓库** → 应显示成功状态（✅）和时间戳
     2. **Git Assistant: 添加远程仓库** → 输入测试远程地址，确认记录成功
     3. **Git Assistant: 提交更改** → 创建提交后，历史记录显示提交信息
     4. **Git Assistant: 快速推送** → 推送成功后，记录显示推送状态
   - 验证每条历史记录包含：
     * 命令图标和名称
     * 执行时间（如"刚刚""2分钟前""1小时前"等相对时间）
     * 成功/失败状态指示（✅ 或 ❌）
     * 失败时显示错误信息
   - **痛点解决**：清晰的执行记录，便于追溯和复盘
2. **历史记录顺序**
   - 确认最新执行的命令显示在列表顶部
   - 最多显示最近 20 条记录（超过 20 条时，旧记录不显示但保留在存储中）
   - **痛点解决**：最新操作最先看到
3. **重新执行历史命令**
   - 在历史记录区域点击任意一条成功执行的命令
   - 确认命令被重新执行，并生成新的历史记录条目
   - 若命令需要用户输入（如分支名称、提交信息），应弹出输入框
   - 验证重新执行失败的命令时，错误提示正常显示
   - **痛点解决**：一键重复执行，无需重新输入
4. **复制命令（如果有）**
   - 如果提供复制功能，验证：
     * 可以复制命令对应的 Git 命令行
     * 复制到剪贴板后可在终端粘贴执行
   - **痛点解决**：学习 Git 命令行语法

#### 痛点场景 4：清除历史记录

**问题**：历史记录过多时需要清理，但又担心误操作。

1. **清除操作验证**
   - 点击"🗑️ 清除历史记录"按钮
   - 确认弹出确认对话框（如"确定要清除所有历史记录吗？"）
   - 确认清除后，历史记录区域应为空
   - 验证清除操作不影响可用命令列表
   - 执行新命令后，历史记录重新开始记录
   - **痛点解决**：安全清除，带确认防止误操作
2. **取消清除**
   - 点击清除按钮后，在确认对话框中选择"取消"
   - 验证历史记录保持不变
   - **痛点解决**：提供反悔机会

#### 痛点场景 5：命令执行反馈

**问题**：执行 Git 命令后不确定是否成功，需要手动检查状态。

1. **成功执行反馈**
   - 执行任意命令（如"快速推送"），确认：
     * 历史记录立即添加新条目，状态为成功（✅）
     * 控制面板数据自动刷新（如分支列表、提交历史等）
     * 相关 UI 元素（侧边栏、状态栏）同步更新
     * VS Code 通知区域显示成功提示
   - **痛点解决**：即时反馈，确认操作成功
2. **执行失败反馈**
   - 制造失败场景（如无远程仓库时执行推送），确认：
     * 历史记录显示失败状态（❌）和错误信息
     * 错误信息完整可读，包含失败原因
     * VS Code 通知区域显示错误提示
     * 不会中断扩展运行，其他功能仍可正常使用
   - **痛点解决**：明确的错误提示，便于排查问题
3. **执行中状态**
   - 执行耗时命令（如克隆大型仓库），确认：
     * 显示加载状态或进度指示
     * 相关按钮禁用，防止重复点击
     * 完成后恢复正常状态
   - **痛点解决**：知道命令正在执行中

#### 痛点场景 6：跨标签页集成验证

**问题**：在快捷指令中执行操作后，需要切换到其他标签页查看结果。

1. **分支操作集成**
   - 在"快捷指令"中执行"创建分支"，验证：
     * 切换到"🌿 分支管理"标签页，新分支应出现在分支树中
     * 切换到"🌳 分支视图"标签页，分支关系图应更新
   - **痛点解决**：数据自动同步，无需手动刷新
2. **推送操作集成**
   - 在"快捷指令"中执行"快速推送"，验证：
     * 切换到"📊 提交图谱"标签页，相关提交节点状态更新
     * 切换到"📅 时间线"标签页，推送时间点应显示
   - **痛点解决**：操作结果在所有视图同步
3. **标签操作集成**
   - 在"快捷指令"中执行"创建标签"，验证：
     * 切换到"🏷️ 标签管理"标签页，新标签应出现在列表中
   - **痛点解决**：标签数据实时同步
4. **远程操作集成**
   - 在"快捷指令"中执行"添加远程仓库"，验证：
     * 切换到"☁️ 远程仓库"标签页，新远程应出现在列表中
   - **痛点解决**：远程配置实时同步

#### 痛点场景 7：边界场景测试

1. **历史记录上限**
   - 快速连续执行 50+ 条命令，确认历史记录保持在最多 20 条显示
   - 清除后重新执行，验证记录计数从 0 开始
   - **痛点解决**：避免历史记录无限增长
2. **并发执行**
   - 快速点击多个命令按钮，验证：
     * 命令按顺序执行，不会并发冲突
     * 每条命令的执行结果都正确记录到历史
   - **痛点解决**：防止操作冲突
3. **网络异常**
   - 断网后执行推送/拉取命令，验证：
     * 显示网络错误提示
     * 历史记录显示失败状态
     * 恢复网络后可重新执行
   - **痛点解决**：网络问题有友好提示

#### 痛点场景 8：UI/UX 细节验证

1. **命令描述**
   - 悬停在命令项上时，显示完整描述信息
   - 描述应清晰说明命令的作用
   - **痛点解决**：新手可以了解命令用途
2. **图标一致性**
   - 确认各分类和命令的图标显示正常，符合语义
   - 图标在不同主题下清晰可辨
   - **痛点解决**：视觉一致性
3. **响应式布局**
   - 调整控制面板宽度，验证命令列表和历史记录区域自适应
   - 窄屏时内容不会溢出或重叠
   - **痛点解决**：适应不同屏幕尺寸
4. **主题适配**
   - 在浅色主题和深色主题下，验证：
     * 命令的可用/禁用状态清晰可辨
     * 成功/失败状态颜色对比度足够
     * 所有文本清晰可读
   - **痛点解决**：适应用户主题偏好

#### 快捷指令验证清单

**基础功能**

- [ ] 界面布局正确（历史区域 + 命令列表）
- [ ] 命令分类显示正确（8 个分类）
- [ ] 分类折叠/展开功能正常
- [ ] 命令可用性基于仓库状态正确判断
- [ ] 历史记录正确显示执行时间和状态
- [ ] 重新执行历史命令功能正常
- [ ] 清除历史记录功能正常（带确认）

**痛点解决验证**

- [ ] 命令分类清晰，易于查找
- [ ] 禁用命令有明确提示
- [ ] 历史记录便于复盘和重复执行
- [ ] 成功/失败反馈即时且清晰
- [ ] 跨标签页数据同步正常
- [ ] 边界场景处理优雅

**UI/UX**

- [ ] 命令描述清晰
- [ ] 图标一致且符合语义
- [ ] 响应式布局正常
- [ ] 浅色/深色主题适配

### 2.6.2 测试分支管理

> **测试目标**：验证分支管理视图（侧边栏 + 控制面板"🌿 分支管理"标签页）在多分支协作场景下的可视化、操作与安全防护能力，确保从创建、切换、合并到清理的完整生命周期体验顺畅。

**重要说明**：

- 控制面板标签页顺序：📋 快捷指令 → 📚 Git 指令集 → ☁️ 远程仓库 → 🌿 分支管理 → 🏷️ 标签管理 → 🧬 Git 视图表 → ⚠️ 冲突解决 → 📊 提交图谱 → 📅 时间线 → 🔥 热力图
- 分支管理视图始终显示"本地分支"和"远程分支"两个部分，即使数量为 0 也会显示标题和空状态提示

#### 痛点场景 1：分支树可视化与信息密度

**问题**：大型项目分支众多，难以快速了解当前状态、远程追踪和未合并分支。

1. **准备工作**
   - 切换到已有仓库的 `main` 分支，确保 `git status` 显示 clean
   - 打开控制面板，确认"🌿 分支管理"标签页位于"☁️ 远程仓库"之后
   - 同时展开侧边栏分支树
2. **布局与信息验证**
   - 验证分支管理视图包含以下部分：
     * 顶部标题"分支管理"和"➕ 创建新分支"按钮
     * **📁 本地分支 (数量)** 部分：
       - 始终显示此标题，即使数量为 0
       - 有分支时显示分支列表，无分支时显示"暂无本地分支"提示
     * **☁️ 远程分支 (数量)** 部分：
       - 始终显示此标题，即使数量为 0
       - 有分支时显示分支列表，无分支时显示"暂无远程分支"提示
     * 当前分支高亮（带 `✓` 或高亮背景）
     * 快捷操作按钮：切换、合并（针对非当前分支）
   - 鼠标悬停在分支项上，验证 tooltip 显示：
     * 完整分支名（如 `feature/branch-tests`）
     * 最后提交作者/时间/摘要
     * 远程追踪状态（已跟踪/未跟踪/落后/领先）
3. **空状态显示验证**
   - 在没有任何分支的仓库中（仅初始提交），验证：
     * 显示"📁 本地分支 (0)"标题
     * 下方显示"暂无本地分支"的空状态提示
     * 显示"☁️ 远程分支 (0)"标题
     * 下方显示"暂无远程分支"的空状态提示
   - **痛点解决**：即使没有分支，界面结构清晰，用户可以清楚看到本地和远程分支的数量
4. **筛选与搜索（如支持）**
   - 在分支列表上方输入关键字（如 `feature/`）
   - 验证列表实时过滤，支持模糊匹配
   - 清空搜索框后列表恢复

#### 痛点场景 2：本地和远程分支分离显示

**问题**：需要清楚区分本地分支和远程分支，了解哪些分支已同步到远程。

1. **验证分离显示**
   - 在已有本地和远程分支的仓库中，打开"🌿 分支管理"标签页
   - 验证：
     * "📁 本地分支 (数量)"部分显示所有本地分支
     * "☁️ 远程分支 (数量)"部分显示所有远程分支（格式为 `remotes/origin/branch-name`）
     * 两个部分始终显示，即使数量为 0
   - **痛点解决**：清晰区分本地和远程分支，避免混淆
2. **验证空状态显示**
   - 在只有本地分支、没有远程分支的仓库中，验证：
     * "📁 本地分支 (N)" 显示分支列表
     * "☁️ 远程分支 (0)" 显示"暂无远程分支"提示
   - 在只有远程分支、没有本地分支的仓库中，验证：
     * "📁 本地分支 (0)" 显示"暂无本地分支"提示
     * "☁️ 远程分支 (N)" 显示远程分支列表
   - **痛点解决**：即使没有分支，界面结构清晰，用户可以清楚看到本地和远程分支的数量

#### 痛点场景 3：规范创建与命名校验

**问题**：命令行创建分支时容易写错命名、忘记校验，导致命名不统一。

1. **创建标准分支**
   - 执行 **Git Assistant: 创建分支**，输入 `feature/branch-tests`
   - 验证：
     * 成功通知（含新分支名称）
     * 分支树即时出现新分支，并显示在"📁 本地分支"部分
     * 命令历史记录新增"创建分支"条目
2. **命名校验**
   - 尝试输入非法名称（如 `feature branch` 或 `Feature@1`）
   - 验证弹窗提示命名规范（仅允许 `a-z0-9/-_` 等）
   - 确认不会创建非法分支
3. **重复名称处理**
   - 尝试创建已存在的分支
   - 验证弹窗提示“分支已存在”，阻止重复

#### 痛点场景 4：安全切换与工作区保护

**问题**：切换分支时忘记清理未提交更改，容易造成冲突或数据丢失。

1. **干净工作区切换**
   - 使用 `Ctrl+Alt+B` 或命令面板切换到 `feature/branch-tests`
   - 验证：
     * 控制面板、状态栏、侧边栏同步显示新分支
     * 瞬时切换，无额外提示
2. **脏工作区阻断**
   - 修改 `src/app.ts`（未提交）
   - 再次尝试切换分支
   - 验证弹出选项：
     * 暂存并切换
     * 放弃更改并切换
     * 取消
   - 选择“取消”后保持在原分支
3. **自动暂存（如支持）**
   - 选择“暂存并切换”
   - 验证：
     * 自动执行 `git stash push` / `pop` 或等效操作
     * 切换完成后工作区恢复
     * 命令历史记录显示“自动暂存”动作

#### 痛点场景 5：远程追踪与推送

**问题**：分支需快速与远程关联并推送，避免忘记设置 upstream。

1. **推送新分支**
   - 在“快捷指令”或命令面板执行 **Git Assistant: 快速推送**
   - 验证：
     * 首次推送弹出“推送并设置 upstream”确认框
     * 推送成功后分支树显示远程图标（如 `origin ↔ local`）
     * 分支视图视图出现 `feature/branch-tests ↔ origin/feature/branch-tests`
2. **落后/领先状态**
   - 在外部终端向远程分支追加提交
   - 刷新分支列表
   - 验证本地分支显示“落后 N 个提交”标签
   - 本地提交未推送时显示“领先 N 个提交”
3. **远程分支列表**
   - 展开 `origin` 节点
   - 验证远程分支与本地对应关系
   - 点击远程分支快速创建本地追踪分支

#### 痛点场景 6：合并策略与冲突预判

**问题**：合并方式多样，开发者需要明确是快进还是非快进，并在冲突发生前获得提示。

1. 快进合并（Fast-forward）

+ 操作步骤：
  - 切回 `main` 分支
  - 在分支树中右键选择“合并到当前分支” → 选择 `feature/branch-tests`
+ 验证项：
  - ✅ 弹出提示层：“检测到可快进合并”
  - ✅ 合并耗时短，无冲突提示
  - ✅ 提交历史**不产生新提交**（仅移动指针）
  - ✅ 控制面板“分支视图”视图实时更新

3. 非快进合并（Three-way Merge）

+ 操作步骤：
  - 创建 `feature/branch-tests-2` 并提交更改
  - 在 `main` 分支增加不同内容的提交（制造分叉）
  - 执行 **Git Assistant: 合并分支**，选择 `feature/branch-tests-2`
+ 验证项：
  - ✅ 合并对话框显示：“将创建合并提交”
  - ✅ 若存在冲突，自动跳转至“⚠️ 冲突解决”标签页
  - ✅ 合并完成后，命令历史记录中标记“成功”或“失败”

3. 合并预检查（Merge Preview）

+ **操作步骤**：在合并对话框中查看预览信息
+ 验证项：
  - ✅ 显示即将合并的提交列表（含作者、摘要、时间）
  - ✅ 提供“仅模拟（--no-commit）”选项（如底层 Git 支持）

---

#### 痛点场景 7：分支清理与保护

**问题**：长期存在的冗余分支影响视图清晰度，误删未合并分支风险高。

1. 删除已合并分支

+ **操作步骤**：在分支树右键 `feature/branch-tests` → “删除分支”
+ 验证项：
  - ✅ 弹窗提示：“是否删除本地分支？是否同步删除远程分支？”
  - ✅ 勾选“同步删除远程”后，需输入分支名二次确认
  - ✅ 删除成功后，本地与远程分支列表同步刷新

3. 删除未合并分支

+ **操作步骤**：对未合并分支执行删除操作
+ 验证项：
  - ✅ 弹窗警告：“该分支尚未合并，删除可能导致代码丢失！”
  - ✅ 未勾选“强制删除”时，操作被阻止
  - ✅ 勾选后仍需二次确认（如输入 `delete` 或分支名）

3. 批量清理（如支持）

+ **操作步骤**：在分支管理界面点击“清理已合并分支”
+ 验证项：
  - ✅ 列出所有已合并的本地/远程分支
  - ✅ 支持多选/全选，逐个确认删除
  - ✅ 操作完成后展示汇总结果（成功/失败数量）

---

#### 痛点场景 8：跨视图联动与回归检查

1. 分支视图联动

+ **操作**：创建或删除分支后，切换至“🌳 分支视图”视图
+ **验证**：节点与连线实时更新，反映最新拓扑关系

2. 提交图谱联动

+ **操作**：完成合并后，切换至“📊 提交图谱”视图
+ **验证**：合并节点正确显示，分支颜色与标签同步更新

3. 命令历史记录

+ **验证**：
  - ✅ 所有关键操作（创建、切换、合并、删除）均记录在历史中
  - ✅ 点击任意历史记录可重放或查看详情

---

#### 分支管理验证清单

✅ 基础能力

+ 分支管理标签页位于远程仓库标签页之后
+ 本地分支和远程分支分离显示，始终显示标题（即使数量为 0）
+ 无分支时显示友好的空状态提示（"暂无本地分支"/"暂无远程分支"）
+ 分支树信息完整（区分本地/远程，高亮当前分支）
+ 支持搜索与过滤（按名称、状态、作者等）
+ 分支创建成功后即时显示
+ 分支命名校验准确（非法字符、重复检测）
+ 切换分支时保护未提交更改（自动暂存/提示）
+ 自动暂存与恢复流程可用且可靠
+ 推送时可设置 upstream（首次推送自动关联）
+ 落后（behind）/领先（ahead）状态标记准确
+ 快进与非快进合并流程可清晰区分
+ 冲突发生时自动引导至冲突解决视图
+ 删除已合并分支时可选同步删除远程
+ 删除未合并分支需强制确认，防止误操作

✅ 痛点解决验证

+ 分支信息可视化清晰（显示作者、最后提交时间、状态）
+ 分支切换安全，避免工作区更改丢失
+ 远程状态追踪无需命令行（自动 fetch 或手动刷新）
+ 合并前可预览影响范围，冲突有明确指引
+ 分支清理具备保护机制（合并状态识别 + 二次确认）
+ 与“Git 视图表”“提交图谱”等视图实时联动

✅ 边界/高级场景

+ 大量分支（50+）时列表加载与渲染性能良好
+ 支持多级路径分支名（如 `feature/payments/api`）正常展示与操作
+ 同名但来自不同远程仓库的分支可清晰区分（如 `origin/main` vs `upstream/main`）
+ Detached HEAD 状态有明确提示，并提供“创建分支”或“返回主干”修复入口
+ 对保护分支（如 `main`、`release/*`）的合并/删除操作需额外确认或权限控制

### 2.6.3 测试 Git 视图表

> **测试目标**：验证 Git 视图表是否正确反映分支/提交关系，能够帮助理解多分支合流，而不会出现断线、错误高亮或滚动异常。

#### 场景 1：基本 DAG 结构与节点类型

1. **准备测试数据**（可复用项目内示例脚本，或手动创建多分支/多合并场景）
2. 在终端运行：

   ```bash
   git log --oneline --graph --all --decorate
   ```

3. 打开控制面板 → 切换到“🧬 Git 视图表”标签页
4. 验证：
   - 图中合并节点数量和位置与命令行 `git log --graph` 一致
   - 节点颜色和大小区分普通提交 / 多分支共享提交 / 合并提交
   - 没有“悬空节点”或明显断线的情况

#### 场景 2：交互与详情面板

1. 在 Git 视图表中：
   - 使用鼠标滚轮缩放，确认缩放中心跟随鼠标位置，缩放范围合理
   - 拖拽空白区域进行平移，验证画布不会卡顿
2. 悬停任意节点，确认工具提示包含：
   - 哈希、提交消息第一行、作者、时间、所属分支等摘要信息
3. 点击节点：
   - 右侧或下方应出现提交详情区域（包含完整消息、作者/邮箱、时间、所属分支、父提交等）
   - 再点击其它节点时，详情区域同步更新，无多余闪烁

#### 场景 3：按需补全提交详情与滚动稳定性

1. 在有较长历史的大仓库中打开 Git 视图表
2. 滚动到中部某一提交行，展开该行的提交详情（如果 UI 提供展开/收起区域）
3. 验证：
   - 在按需加载/补全提交详情（消息、作者等）后，当前行仍保持在视口内
   - 多次展开/收起同一行或相邻行时，滚动位置不会突然跳远（即不存在明显“跳屏”）
4. 切换到其他标签页再切回 Git 视图表，确认：
   - 之前的滚动位置和已展开的行状态正确恢复

### 2.6.4 测试冲突解决

> **测试目标**：验证冲突解决功能能有效解决程序员在 Git 合并中遇到的常见痛点，如冲突检测不及时、冲突标记难以理解、不知道选择哪个版本、容易遗漏冲突文件等。

#### 痛点场景 1：实时冲突检测和即时提醒

**问题**：执行 `git merge` 或 `git pull` 后，冲突不会自动提醒，需要手动执行 `git status` 才能发现，导致遗漏冲突。

1. **触发冲突并验证实时检测**

```powershell
# 初始化仓库（如果尚未初始化）
git init

# 确保 main 是默认分支（Git 2.28+）
git checkout -b main

# 创建初始提交（必须有，否则后续 commit -am 会失败）
echo "# My Project" > README.md
git add README.md
git commit -m "Initial commit"

# 创建 feature 分支并添加 Alice
git checkout -b feature/user-profile
New-Item -ItemType Directory -Path src -Force
Set-Content -Path src/user.ts -Value "function getUser() { return 'Alice'; }"
git add src/user.ts
git commit -m "Add user profile feature"

# 切回 main，创建 src 目录并添加 Bob
git checkout main
New-Item -ItemType Directory -Path src -Force
Set-Content -Path src/user.ts -Value "function getUser() { return 'Bob'; }"
git add src/user.ts
git commit -m "Update user function"

# 合并触发冲突
git checkout feature/user-profile
git merge main
```

2. **验证自动冲突检测**
   - **侧边栏自动更新**：
     * 合并命令执行后，侧边栏“冲突检测”视图应**立即**显示红色警告图标 ⚠️
     * 冲突文件列表自动出现在侧边栏，无需手动刷新
     * 文件图标显示为警告状态（红色/黄色）
   - **控制面板自动刷新**：
     * 切换到控制面板“冲突解决”标签页
     * 验证页面顶部显示："发现 X 个冲突文件"
     * 冲突文件列表立即显示，无需点击刷新按钮
   - **编辑器高亮提示**：
     * 打开包含冲突的文件（如 `src/user.ts`）
     * 验证冲突区域自动高亮显示（红色背景或边框）
     * 验证冲突标记行（`<<<<<<<`, `=======`, `>>>>>>>`）有特殊标识
   - **痛点解决**：无需手动检查，冲突立即可见，避免遗漏
3. **状态栏和通知验证**
   - 验证 VS Code 状态栏显示合并状态（如果有）
   - 验证是否弹出通知提示："发现 X 个冲突文件，需要解决"
   - 点击通知应跳转到冲突解决界面



#### 痛点场景 2：理解冲突标记和代码对比

**问题**：Git 的冲突标记（`<<<<<<< HEAD`, `=======`, `>>>>>>> branch`）对新手不友好，难以理解当前版本和传入版本的区别。

1. **创建清晰的冲突示例**

```powershell
# 初始化仓库（如果尚未初始化）
git init

# 确保 main 是默认分支（Git 2.28+）
git checkout -b main

# 创建初始提交（必须有，否则后续 commit -am 会失败）
echo "# My Project" > README.md
git add README.md
git commit -m "Initial commit"

# 确保你在干净的仓库中（已有初始提交，例如 README.md）
# 如果还没有 src 目录，在 main 分支也要创建！

# 切换到 main 并确保有基础结构
git checkout main

# 创建 src 目录（如果还没有）
New-Item -ItemType Directory -Path src -Force

# 创建 feature 分支
git checkout -b feature/api-refactor

# 在 feature 分支写入 config.ts
@"
// API Configuration
const API_URL = 'https://api.example.com';
const TIMEOUT = 5000;
"@ | Out-File -Encoding utf8 src/config.ts

# 显式添加并提交（不能只用 -am，因为是新文件！）
git add src/config.ts
git commit -m "Refactor API config"

# 切回 main 分支
git checkout main

# 再次确保 src 目录存在（虽然上面已创建，但保险起见）
New-Item -ItemType Directory -Path src -Force

# 在 main 分支写入不同内容的 config.ts
@"
// API Settings
const API_URL = 'https://api.production.com';
const TIMEOUT = 3000;
"@ | Out-File -Encoding utf8 src/config.ts

# 显式添加并提交
git add src/config.ts
git commit -m "Update API settings"

# 回到 feature 分支并合并 main（触发冲突）
git checkout feature/api-refactor
git merge main
```

2. **验证冲突编辑器显示**
   - 在冲突列表中，点击冲突文件 `src/config.ts`
   - 点击“打开文件”按钮，验证：
     * 文件在编辑器中打开
     * 冲突区域有清晰的视觉分隔
     * 冲突标记（`<<<<<<< HEAD`, `=======`, `>>>>>>> main`）可见
   - **痛点解决**：即使不熟悉 Git 标记，也能通过界面理解冲突结构
3. **验证三栏对比视图（如果有）**
   - 如果扩展提供了三栏对比视图（当前/传入/合并结果）
   - 验证：
     * 左侧显示"当前更改"（HEAD 版本）
     * 中间显示"传入更改"（要合并的分支版本）
     * 右侧显示合并结果预览
   - **痛点解决**：并排对比，清晰理解两个版本的差异

#### 痛点场景 3：快速选择保留哪个版本的代码

**问题**：手动编辑冲突标记容易出错，不知道应该选择当前版本还是传入版本，或者需要合并两者。

1. **验证快速解决选项**
   - 在冲突解决界面，点击冲突文件展开操作选项
   - 验证存在三个快速解决按钮：
     * **"接受当前更改"**（←）：保留本地/当前分支的修改
     * **"接受传入更改"**（→）：使用要合并分支的修改
     * **"接受所有更改"**（↕）：合并两个版本的内容
   - **痛点解决**：一键选择，无需手动删除冲突标记
2. **测试快速解决流程**

```powershell
# 已有冲突的情况下
# 在 VS Code 冲突解决界面
```

    - 选择一个冲突文件（如 `src/config.ts`）
        - 点击"接受传入更改"按钮
        - 验证：
        * 冲突标记自动删除
        * 文件内容变为传入版本
        * 文件自动保存
        * 控制面板中该文件从冲突列表移除或标记为"已解决"
        - **痛点解决**：无需手动编辑，降低出错概率

3. **验证按钮描述清晰**
   - 验证每个按钮有清晰的图标和文字说明
   - 验证按钮有悬停提示，说明操作的具体含义
   - **痛点解决**：即使是新手，也能理解每个选项的作用

#### 痛点场景 4：处理多个冲突文件时的追踪和管理

**问题**：合并时可能有多个文件发生冲突，容易遗漏某个文件的冲突，导致合并不完整。

1. **创建多文件冲突场景**

```powershell
# 1. 初始化仓库（如果尚未初始化）
git init

# 2. 创建并切换到 main 分支（关键！）
git checkout -b main

# 3. 创建初始提交（必须有！）
Set-Content -Path README.md -Value "# Test Repository"
git add README.md
git commit -m "Initial commit"

# 4. 现在创建 feature 分支
git checkout -b feature/multi-file-conflict

# 5. 创建 src 目录和文件（版本 A）
New-Item -ItemType Directory -Path src -Force | Out-Null
Set-Content -Path src/file1.ts -Value "version A"
Set-Content -Path src/file2.ts -Value "version A"
Set-Content -Path src/file3.ts -Value "version A"
git add src/
git commit -m "Multiple file changes (version A)"

# 6. 切回 main 分支
git checkout main

# 7. 在 main 上也创建同名文件，但内容不同（版本 B）
New-Item -ItemType Directory -Path src -Force | Out-Null
Set-Content -Path src/file1.ts -Value "version B"
Set-Content -Path src/file2.ts -Value "version B"
Set-Content -Path src/file3.ts -Value "version B"
git add src/
git commit -m "Different changes (version B)"

# 8. 回到 feature 分支并合并 main → 触发多文件冲突
git checkout feature/multi-file-conflict
git merge main
```

2. **验证冲突列表管理**
   - 在控制面板“冲突解决”标签页，验证：
     * 显示所有冲突文件列表（`file1.ts`, `file2.ts`, `file3.ts`）
     * 每个文件显示完整路径
     * 已解决的文件有标识（如绿色勾选标记）
     * 未解决的文件突出显示（如红色警告图标）
   - **痛点解决**：一目了然所有冲突文件，不会遗漏
3. **逐个解决验证**
   - 点击第一个冲突文件，选择"接受当前更改"
   - 验证该文件在列表中标记为"已解决"
   - 验证冲突计数更新（如"发现 2 个冲突文件"）
   - 继续解决剩余冲突，验证每个文件的解决状态独立追踪
   - **痛点解决**：清晰的进度追踪，知道还有多少冲突待解决
4. **批量操作验证（如果有）**
   - 如果支持批量操作，验证：
     * "全部接受当前更改"按钮（谨慎使用）
     * "全部接受传入更改"按钮
     * 批量操作的确认对话框
   - **痛点解决**：特定场景下可以快速处理大量冲突

#### 痛点场景 5：解决冲突后的标记和提交流程

**问题**：解决冲突后容易忘记执行 `git add` 标记为已解决，或不知道如何完成合并提交。

1. **验证标记已解决功能**
   - 解决一个冲突文件后，验证：
     * 文件从冲突列表移除，或显示"已解决"状态
     * 侧边栏冲突计数减少
     * 可以执行 **Git Assistant: 标记冲突已解决** 命令
     * 执行后，`git status` 显示文件在暂存区（已 add）
2. **验证完成合并流程**

```powershell
# 所有冲突解决后
# 在扩展中完成合并
```

    - 解决所有冲突文件后，验证：
        * 控制面板显示"所有冲突已解决"提示
        * 提供"完成合并"或"提交合并"按钮/命令
        * 执行后自动创建合并提交
        * 提交信息包含合并信息（如 "Merge branch 'feature/xxx' into main"）
        - **痛点解决**：明确的流程指引，不会卡在合并中间状态

3. **验证放弃合并功能**
   - 如果冲突太复杂，想放弃合并，验证：
     * 存在"放弃合并"或"中止合并"按钮/命令
     * 执行后自动执行 `git merge --abort`
     * 工作区恢复到合并前的状态
     * 冲突标记全部清除
   - **痛点解决**：提供回退选项，避免陷入混乱状态

#### 痛点场景 6：复杂冲突和嵌套冲突的处理

**问题**：同一个文件可能有多个冲突区域，或者冲突代码嵌套复杂，难以逐个处理。

1. **创建多段冲突场景**

```powershell
# 0. 确保在一个干净的新目录里（你已在 E:\TestRepo）

# 1. 初始化 Git 仓库（你已做）
git init
git checkout -b main

# 2. 初始提交（你已做）
Set-Content -Path README.md -Value "# TestRepo"
git add README.md
git commit -m "Initial commit"

# 3. 创建特性分支
git checkout -b feature/interactive-conflicts

# ✅ 关键修复：创建 src 目录！
New-Item -ItemType Directory -Path src -Force | Out-Null

# 4. 在 feature 分支写入“二进制版本 A”（多段冲突）
@"
function func1() {
    return 'A - func1';
}

console.log('--- separator ---'); // 分隔行，两个分支保持完全一致

function func2() {
    return 'A - func2';
}

console.log('--- separator ---'); // 分隔行，两个分支保持完全一致

function func3() {
    return 'A - func3';
}
"@ | Out-File -Encoding utf8 src/utils.ts

# 添加并提交
git add src/utils.ts
git commit -m "Version A with separators"

# 5. 回到 main 分支
git checkout main

# ✅ 再次确保 src 目录存在（虽然可能已有，但保险起见）
New-Item -ItemType Directory -Path src -Force | Out-Null

# 6. 在 main 分支写入“二进制版本 B”（多段冲突）
@"
function func1() {
    return 'B - func1';
}

console.log('--- separator ---'); // 分隔行，两个分支保持完全一致

function func2() {
    return 'B - func2';
}

console.log('--- separator ---'); // 分隔行，两个分支保持完全一致

function func3() {
    return 'B - func3';
}
"@ | Out-File -Encoding utf8 src/utils.ts

# 添加并提交
git add src/utils.ts
git commit -m "Version B with separators"

# 7. 回到 feature 分支并合并 main → 触发冲突
git checkout feature/interactive-conflicts
git merge main
```

2. **验证多段冲突处理**
   - 打开冲突文件，验证：
     * 每个冲突区域独立高亮显示
     * 可以使用"接受当前/传入/所有更改"逐个解决每个冲突
     * 解决一个冲突后，其他冲突区域仍然可见
     * 所有冲突解决后，文件可以正常保存
3. **验证嵌套冲突**
   - 如果冲突代码包含嵌套结构（如嵌套函数、对象等）
   - 验证冲突标记正确识别嵌套范围
   - 验证解决选项能正确处理嵌套结构
   - **痛点解决**：复杂代码结构也能正确处理

#### 痛点场景 7：二进制文件和特殊文件冲突

**问题**：图片、PDF 等二进制文件发生冲突时，无法通过文本编辑器解决，需要特殊处理。

1. **创建二进制文件冲突**

```powershell
# === 1. 初始化仓库（如果尚未初始化）===
if (-not (Test-Path .git)) {
    git init
    git checkout -b main
    Set-Content -Path README.md -Value "# Test Repo"
    git add README.md
    git commit -m "Initial commit"
}

# === 2. 确保在 main 分支，并创建 src 目录 ===
git checkout main
New-Item -ItemType Directory -Path src -Force | Out-Null

# === 3. 创建 feature 分支 ===
git checkout - b feature/add-image

# === 4. 在 feature 分支写入“二进制版本 A” ===
# 使用不同的字节序列模拟不同图片
$bytesA = [System.Text.Encoding]::UTF8.GetBytes("fake png version A")
[System.IO.File]::WriteAllBytes("$PWD/src/logo.png", $bytesA)

git add src/logo.png
git commit -m "Add logo A"

# === 5. 切回 main 分支 ===
git checkout main

# === 6. 在 main 分支写入“二进制版本 B” ===
New-Item -ItemType Directory -Path src -Force | Out-Null
$bytesB = [System.Text.Encoding]::UTF8.GetBytes("fake png version B")  # 内容不同！
[System.IO.File]::WriteAllBytes("$PWD/src/logo.png", $bytesB)

git add src/logo.png
git commit -m "Add logo B"

# === 7. 回到 feature 分支并合并 main → 触发二进制冲突 ===
git checkout feature/add-image
git merge main
```

2. **验证二进制文件处理**
   - 在冲突列表中看到 `src/logo.png`
   - 点击该文件，验证：
     * 显示提示："二进制文件冲突，请手动选择版本"
     * 提供选项："保留当前版本"或"使用传入版本"
     * 无法直接编辑文件内容（这是正常的）
   - **痛点解决**：明确提示二进制文件需要特殊处理，避免用户困惑
3. **验证其他特殊文件**
   - 测试 JSON、XML、YAML 等格式文件的冲突处理
   - 验证特殊字符（如中文、emoji）在冲突标记中的显示
   - 验证大文件（>1MB）的冲突检测性能

#### 痛点场景 8：冲突来源追溯和上下文理解

**问题**：发生冲突时，不知道冲突是从哪个分支来的，或者不知道两个版本的修改背景。

1. **验证冲突信息显示**
   - 在冲突解决界面，验证显示：
     * 当前分支名称（HEAD 指向的分支）
     * 要合并的分支名称
     * 冲突文件的路径
   - **痛点解决**：清楚知道冲突的来源，便于决策
2. **验证提交信息追溯（如果有）**
   - 如果支持，验证可以查看：
     * 当前版本的提交信息和作者
     * 传入版本的提交信息和作者
     * 冲突引入的提交哈希
   - **痛点解决**：了解修改背景，做出更好的合并决策
3. **结合分支视图验证**
   - 切换到"分支视图"标签页
   - 验证可以看到当前合并操作涉及的分支
   - 验证分支关系图能显示合并进行中的状态
   - **痛点解决**：在更大的上下文中理解冲突

#### 痛点场景 9：冲突解决后的验证和测试

**问题**：解决冲突后不确定是否正确，担心破坏了代码逻辑或引入了 bug。

1. **验证解决后的状态检查**
   - 所有冲突解决后，验证：
     * 文件可以正常保存
     * 没有残留的冲突标记（`<<<<<<<`, `=======`, `>>>>>>>`）
     * `git status` 显示文件在暂存区
     * 可以正常编译或运行语法检查（如果配置了）
2. **验证合并提交创建**
   - 完成合并后，验证：
     * 创建了合并提交
     * 提交信息正确
     * 提交历史中可以看到合并记录
     * 可以查看合并提交的详细信息
3. **验证回退机制**
   - 如果发现解决有误，验证可以：
     * 查看合并提交的差异（`git show`）
     * 如果需要，可以撤销合并提交（`git reset --hard HEAD~1`）
     * 重新开始合并流程
   - **痛点解决**：提供验证和回退路径，降低风险

#### 痛点场景 10：团队协作中的冲突预防和处理

**问题**：多人同时修改同一文件时容易产生冲突，需要提前了解潜在的冲突风险。

1. **验证冲突预防提示（如果有）**
   - 在拉取远程更改前，验证是否有提示：
     * "远程分支有新的提交，可能导致冲突"
     * 显示哪些文件在本地和远程都有修改
   - **痛点解决**：提前了解潜在冲突，做好准备
2. **验证合并前的预览（如果有）**
   - 执行合并前，验证是否可以预览：
     * 将要合并的提交列表
     * 可能受影响的文件列表
     * 预估的冲突文件
   - **痛点解决**：合并前评估影响，减少意外
3. **验证协作场景**

```powershell
# 模拟团队协作
# 开发者 A 的修改
git checkout main
git checkout -b alice/feature
echo "Alice's code" > src/app.ts
git commit -am "Alice's changes"
git push origin alice/feature

# 开发者 B 在本地修改同一文件
git checkout main
echo "Bob's code" > src/app.ts
git commit -am "Bob's changes"

# B 尝试合并 A 的分支（使用 --no-ff 创建三路合并，以便在分支视图中显示）
git merge --no-ff alice/feature -m "Merge alice/feature"
```

    - 验证冲突检测能正确识别团队协作场景
        - 验证解决冲突后，可以继续协作流程
        - **痛点解决**：支持团队协作的完整流程

#### 验证清单

**基础功能**

- [x] 冲突检测实时且准确
- [x] 冲突列表清晰显示所有冲突文件
- [x] 冲突编辑器功能完整
- [x] 快速解决选项（当前/传入/所有）正常工作
- [x] 标记已解决功能正常
- [x] 完成合并流程顺畅

**痛点解决验证**

- [x] 无需手动检查，冲突立即可见
- [x] 冲突标记清晰易懂
- [ ] 可以快速选择保留哪个版本
- [ ] 多个冲突文件不会遗漏
- [ ] 解决后流程清晰，不会卡住
- [ ] 复杂冲突也能正确处理
- [ ] 二进制文件有特殊处理
- [ ] 冲突来源信息清晰
- [ ] 解决后可以验证正确性
- [ ] 支持团队协作场景

**边界情况**

- [ ] 空冲突文件处理
- [ ] 只有空白字符差异的冲突
- [ ] 非常大的冲突文件性能
- [ ] 合并中止后的状态恢复
- [ ] 同时打开多个冲突文件的处理

**用户体验**

- [ ] 界面友好，提示清晰
- [ ] 操作流程符合直觉
- [ ] 错误提示有帮助性
- [ ] 性能良好，无明显延迟

### 2.6.5 测试远程仓库管理

> **测试目标**：验证远程仓库管理功能能有效解决程序员在 Git 协作中的常见痛点，如远程配置复杂、多远程管理混乱、URL 更新繁琐等。

#### 痛点场景 1：添加远程仓库

**问题**：新项目或 Fork 仓库需要配置远程地址，命令行操作容易出错。

1. **验证添加远程功能**
   - 打开控制面板，切换到"☁️ 远程仓库"标签页
   - 确认显示"当前仓库还没有任何远程仓库"提示
   - 点击"➕ 添加远程仓库"按钮
   - 输入远程名称（如 `origin`）和地址（如 `https://github.com/user/repo.git`）
   - 验证：
     * 顶部“🌿 当前分支上游 / 📤 推送远程”摘要区域实时更新——若当前分支 tracking 信息缺失则给出“尚未设置上游”告警；若跟踪信息存在则显示 `origin/main` 等；若未设置上游则以首个远程名称作为推送参考
     * 远程列表立即显示新添加的远程
     * 显示 fetch 和 push 地址
     * 执行 `git remote -v` 确认配置正确
   - **痛点解决**：可视化添加，无需记忆命令格式
2. **验证多远程场景**
   - 添加第二个远程（如 `upstream`，地址为原始仓库）
   - 验证远程列表显示两个远程，各自地址正确
   - **痛点解决**：清晰管理多个远程（如 Fork 工作流中的 origin 和 upstream）

#### 痛点场景 2：编辑远程仓库

**问题**：远程仓库 URL 变更（如从 HTTPS 切换到 SSH，或仓库迁移）需要手动执行 `git remote set-url`。

1. **验证编辑功能**
   - 在远程列表中，点击目标远程的"✏️"编辑按钮
   - 修改远程名称（如 `origin` → `main-remote`）
   - 修改远程地址（如切换到 SSH 格式 `git@github.com:user/repo.git`）
   - 点击确认，验证：
     * 远程名称和地址立即更新
     * `git remote -v` 显示新配置
   - **痛点解决**：可视化编辑，避免命令行出错
2. **验证仅修改名称**
   - 编辑远程，仅修改名称，保持 URL 不变
   - 验证名称更新，URL 保持不变
3. **验证仅修改 URL**
   - 编辑远程，仅修改 URL，保持名称不变
   - 验证 URL 更新，名称保持不变

#### 痛点场景 3：删除远程仓库

**问题**：不再需要的远程（如临时测试远程）需要清理，避免混乱。

1. **验证删除功能**
   - 在远程列表中，点击目标远程的"🗑️"删除按钮
   - 确认弹出确认对话框，显示警告信息
   - 点击"删除"确认
   - 验证：
     * 远程从列表中移除
     * `git remote -v` 不再显示该远程
   - **痛点解决**：安全删除，带确认防止误操作
2. **验证取消删除**
   - 点击删除按钮后，在确认对话框中选择"取消"
   - 验证远程仍然存在

#### 痛点场景 4：远程信息展示

**问题**：不清楚当前配置了哪些远程，以及它们的用途。

1. **验证信息展示**
   - 在远程仓库标签页，验证每个远程显示：
     * 远程名称（如 `origin`、`upstream`）
     * Fetch 地址
     * Push 地址（如果与 Fetch 不同）
     * “当前分支跟踪”徽标（当远程名称与 `git status` 的 tracking 信息一致时出现）
     * “🔗”按钮可用时可跳转至浏览器预览（依赖 `convertGitUrlToBrowserUrl` 转换）
   - **痛点解决**：一目了然所有远程配置
2. **验证空状态提示**
   - 在没有远程的仓库中，验证显示友好提示
   - 提示应引导用户添加远程

#### 痛点场景 5：一键打开远程地址

**问题**：团队成员需要快速跳转到远程托管平台（GitHub/GitLab/Gitea 等）查看 PR、设置，复制 CLI URL 不够直观。

1. **验证可转换的 URL**
   - 选中带有 HTTPS 或 SSH 地址的远程（如 `https://github.com/user/repo.git` 或 `git@github.com:user/repo.git`）
   - 点击远程卡片右上角的“🔗”按钮
   - 验证：
     * 若 URL 可被 `convertGitUrlToBrowserUrl` 转换，按钮处于可用状态并打开默认浏览器，指向对应 Web 页面
     * 若 URL 无法转换（如自建协议或本地路径），按钮为禁用状态并显示提示“无法转换为浏览器链接”
   - **痛点解决**：无需手动拼装浏览器地址，一键跳转远程仓库页面

2. **验证跟踪分支提示**
   - 将当前分支设置为跟踪 `origin/main`（或任何远程/分支组合）
   - 返回远程列表，确认对应远程卡片展示“当前分支跟踪”徽标，顶部摘要更新为 `🌿 当前分支上游：origin/main`
   - 切换到未设置 upstream 的本地分支，确认摘要区域重新显示告警并提示用户需通过 `git push -u` 或 `git branch --set-upstream-to` 手动设置
   - **痛点解决**：在远程管理视图即可识别当前分支的远程指向，降低误推送风险；但默认推送远程仍由快捷命令临时选择，用户需根据提示自行设置上游

#### 验证清单

**基础功能**

- [ ] 添加远程仓库功能正常
- [ ] 编辑远程名称功能正常
- [ ] 编辑远程 URL 功能正常
- [ ] 删除远程仓库功能正常（带确认）
- [ ] 远程列表正确显示所有远程

**痛点解决验证**

- [ ] 可视化添加远程，无需记忆命令
- [ ] 支持多远程管理（origin + upstream）
- [ ] 可视化编辑远程配置
- [ ] 安全删除带确认对话框
- [ ] 远程信息展示清晰完整

**边界情况**

- [ ] 空仓库（无远程）显示友好提示
- [ ] 远程名称校验（不允许非法字符）
- [ ] 远程 URL 校验（必须是有效 Git 地址）
- [ ] 重复远程名称的处理

---

### 2.6.6 测试标签管理

> **测试目标**：验证标签管理功能能有效解决程序员在版本发布中的常见痛点，如标签创建繁琐、推送遗漏、批量操作困难等。

#### 痛点场景 1：创建标签

**问题**：版本发布时需要打标签，命令行操作繁琐，容易忘记添加注释。

1. **准备测试环境**

```powershell
cd E:\TestRepo
git checkout main
echo "version 1.0" > version.txt
git add .
git commit -m "Prepare for v1.0.1 release"
```

2. **验证创建带注释标签**
   - 打开控制面板，切换到"🏷️ 标签管理"标签页
   - 点击"➕ 创建新标签"按钮
   - 输入标签名称：`v1.0.1`
   - 选择"带注释的标签"类型
   - 输入注释：`Release version 1.0.1`
   - 选择"当前提交"
   - 验证：
     * 标签列表立即显示新标签
     * 显示标签名称、提交哈希、注释、创建时间
     * 执行 `git tag -l` 确认标签存在
     * 执行 `git show v1.0.1` 确认注释正确
   - **痛点解决**：引导式创建，不会遗漏注释
3. **验证创建轻量标签**
   - 再次点击"➕ 创建新标签"
   - 输入标签名称：`v1.0.1-beta`
   - 选择"轻量级标签"类型
   - 验证标签创建成功，无注释信息
   - **痛点解决**：支持两种标签类型，满足不同需求
4. **验证指定提交打标签**
   - 点击"➕ 创建新标签"
   - 选择"指定提交"
   - 从提交列表中选择历史提交
   - 验证标签指向正确的提交
   - **痛点解决**：可以给历史版本补打标签

#### 痛点场景 2：推送标签

**问题**：`git push` 默认不推送标签，容易忘记单独推送，导致远程缺少版本标签。

1. **验证推送单个标签**
   - 在标签列表中，点击 `v1.0.1` 标签的"📤"推送按钮
   - 验证：
     * 推送进度显示
     * 推送成功后显示提示
     * 远程仓库可以看到该标签（`git ls-remote --tags origin`）
   - **痛点解决**：一键推送，不会遗漏
2. **验证推送所有标签**
   - 创建多个本地标签（如 `v1.0.1`、`v1.0.2`）
   - 点击"📤 推送所有标签"按钮
   - 确认弹出确认对话框
   - 点击确认，验证所有标签推送成功
   - **痛点解决**：批量推送，适合版本发布后的统一同步
3. **验证强制推送（覆盖远程标签）**
   - 修改本地 `v1.0.1` 标签指向不同提交：

```powershell
git tag -d v1.0.1
git tag -a v1.0.1 -m "Updated release" HEAD~1
```

    - 在标签管理中推送 `v1.0.1`
        - 验证提示远程已存在同名标签
        - 选择"强制推送（覆盖）"
        - 验证远程标签被更新
        - **痛点解决**：支持修正错误的版本标签

#### 痛点场景 3：删除标签

**问题**：错误创建的标签需要删除，同时要处理本地和远程的同步问题。

1. **验证删除本地标签**
   - 在标签列表中，点击目标标签的"🗑️"删除按钮
   - 选择"仅删除本地标签"
   - 验证：
     * 标签从列表中移除
     * `git tag -l` 不再显示该标签
     * 远程标签仍然存在（如果之前推送过）
   - **痛点解决**：明确区分本地和远程删除
2. **验证同时删除本地和远程标签**
   - 点击删除按钮
   - 选择"同时删除远程标签"
   - 验证：
     * 本地标签删除
     * 远程标签也被删除（`git ls-remote --tags origin` 确认）
   - **痛点解决**：一步完成本地和远程的清理
3. **验证删除确认**
   - 删除操作应弹出确认对话框
   - 显示警告信息（如"此操作无法撤销"）
   - 取消操作应保留标签
   - **痛点解决**：防止误删除重要版本标签

#### 痛点场景 4：标签列表和信息展示

**问题**：不清楚当前有哪些版本标签，以及它们的详细信息。

1. **验证标签列表展示**
   - 在标签管理标签页，验证显示：
     * 所有本地标签
     * 每个标签的名称
     * 指向的提交哈希（前 8 位）
     * 标签注释（如果有）
     * 创建时间
   - **痛点解决**：一目了然所有版本标签
2. **验证标签排序**
   - 验证标签按创建时间倒序排列（最新的在前）
   - **痛点解决**：快速找到最新版本
3. **验证空状态提示**
   - 在没有标签的仓库中，验证显示友好提示
   - 提示应引导用户创建第一个标签
   - **痛点解决**：新手友好

#### 痛点场景 5：标签操作的实时反馈

**问题**：标签操作后不确定是否成功，需要手动刷新或执行命令确认。

1. **验证创建反馈**
   - 创建标签后，验证：
     * 标签列表立即更新
     * 显示成功/失败状态指示
     * 失败时显示错误信息
   - **痛点解决**：即时反馈，无需手动刷新
2. **验证推送反馈**
   - 推送标签后，验证：
     * 显示推送进度
     * 成功/失败状态清晰
     * 网络错误有友好提示
   - **痛点解决**：知道推送是否成功
3. **验证删除反馈**
   - 删除标签后，验证：
     * 标签从列表中移除
     * 显示删除成功提示
   - **痛点解决**：确认删除操作完成

#### 验证清单

**基础功能**

- [ ] 创建带注释标签功能正常
- [ ] 创建轻量标签功能正常
- [ ] 指定提交打标签功能正常
- [ ] 推送单个标签功能正常
- [ ] 推送所有标签功能正常
- [ ] 强制推送（覆盖）功能正常
- [ ] 删除本地标签功能正常
- [ ] 删除本地+远程标签功能正常
- [ ] 标签列表正确显示所有标签

**痛点解决验证**

- [ ] 引导式创建，不会遗漏注释
- [ ] 支持带注释和轻量两种标签类型
- [ ] 可以给历史提交打标签
- [ ] 一键推送，不会遗漏
- [ ] 批量推送所有标签
- [ ] 支持强制覆盖远程标签
- [ ] 明确区分本地和远程删除
- [ ] 删除操作有确认对话框
- [ ] 标签信息展示完整（名称、哈希、注释、时间）
- [ ] 操作有即时反馈

**边界情况**

- [ ] 空仓库（无标签）显示友好提示
- [ ] 标签名称校验（不允许非法字符）
- [ ] 重复标签名称的处理
- [ ] 无远程仓库时推送的处理
- [ ] 网络错误时的友好提示

**性能验证**

- [ ] 标签列表加载速度（使用 `git for-each-ref` 批量获取）
- [ ] 大量标签（50+）时的性能

---

### 2.6.7 测试提交历史与分析

> **测试目标**：验证提交历史可视化功能能有效解决程序员在代码审查和项目分析中的常见痛点，如提交历史难以理解、分支关系不清晰、贡献统计困难等。

#### 痛点场景 1：2D 提交图谱（📊 提交图谱标签页）

**问题**：命令行 `git log --graph` 输出难以阅读，分支关系不直观，难以理解项目演进。

1. **准备测试数据**

```powershell
cd E:\TestRepo
git checkout main

# 创建多个分支和提交，模拟真实项目
git checkout -b feature/api
echo "api v1" > src/api.ts
git commit -am "Add API v1"
echo "api v2" > src/api.ts
git commit -am "Update API to v2"

git checkout main
git checkout -b feature/ui
echo "ui component" > src/ui.tsx
git commit -am "Add UI component"

git checkout main
git merge --no-ff feature/api -m "Merge feature/api"  # 使用 --no-ff 创建三路合并
git merge --no-ff feature/ui -m "Merge feature/ui"    # 使用 --no-ff 创建三路合并
```

2. **验证图谱渲染**
   - 打开控制面板，切换到"📊 提交图谱"标签页
   - 验证：
     * 所有提交节点正确显示（圆形节点）
     * 分支关系连线正确（合并提交有多条父连线）
     * 当前分支的提交节点有高亮标识
     * 节点颜色区分不同分支
   - **痛点解决**：图形化展示，分支关系一目了然
3. **验证高 DPI 渲染**
   - 在高分辨率显示器上查看图谱
   - 验证：
     * 节点和连线清晰锐利，无模糊
     * 文字标签清晰可读
     * 自动适配设备像素比
   - **痛点解决**：高清显示，适配现代显示器
4. **验证交互功能**
   - **缩放**：
     * 使用鼠标滚轮向上滚动（放大）
     * 使用鼠标滚轮向下滚动（缩小）
     * 验证缩放范围合理（0.1x - 4x）
     * 缩放时节点和文字比例正确
   - **拖拽**：
     * 点击并拖拽空白区域，平移视图
     * 点击并拖拽节点，调整节点位置
     * 验证连线跟随节点移动
   - **悬停**：
     * 鼠标悬停在提交节点上
     * 验证显示提交详情（哈希、作者、时间、消息）
   - **点击**：
     * 点击提交节点
     * 验证显示完整提交信息或跳转到详情
   - **痛点解决**：交互式探索，深入了解每个提交
5. **验证提交信息显示**
   - 验证每个节点显示：
     * 提交哈希（前 7-8 位）
     * 提交消息（截断显示）
     * 作者信息
     * 提交时间（相对时间或绝对时间）
   - 验证文本换行处理正确（支持中英文混合）
   - **痛点解决**：关键信息一目了然
6. **验证大仓库性能**
   - 在有 100+ 提交的仓库中测试
   - 验证：
     * 图谱加载时间 < 2 秒
     * 交互（缩放、拖拽）流畅，无卡顿
     * 内存占用合理
   - **痛点解决**：大项目也能流畅使用

#### 痛点场景 2：时间线视图（📅 时间线标签页）

**问题**：难以了解项目的提交频率和活跃度，不知道团队什么时候最忙碌。

1. **验证日历热力图**
   - 打开控制面板，切换到"📅 时间线"标签页
   - 验证日历热力图显示：
     * 按月份展示日历网格
     * 每个日期方块颜色深浅表示提交数量
     * 颜色统一使用 #0e639c 色系
     * 无提交的日期显示浅色或空白
   - **痛点解决**：一眼看出项目活跃度分布
2. **验证年月切换**
   - 点击年份/月份切换按钮
   - 验证：
     * 可以查看历史月份的提交分布
     * 切换时数据正确更新
     * 当前月份有标识
   - **痛点解决**：回顾历史活跃度
3. **验证日期详情**
   - 点击某个有提交的日期方块
   - 验证显示该日期的提交列表或数量
   - **痛点解决**：深入了解特定日期的提交
4. **验证柱状图时间线**
   - 验证下方柱状图显示：
     * X 轴为日期
     * Y 轴为提交数量
     * 柱状图高度与提交数量成正比
   - 验证柱状图与日历热力图数据一致
   - **痛点解决**：直观展示提交趋势
5. **验证主题适配**
   - 在浅色主题下查看时间线
   - 在深色主题下查看时间线
   - 验证：
     * 颜色对比度足够，清晰可读
     * 自动适配主题切换
   - **痛点解决**：适应用户主题偏好

#### 痛点场景 3：热力图分析（🔥 热力图标签页）

**问题**：不知道哪些文件被频繁修改（热点文件），不清楚团队成员的贡献分布。

1. **验证文件修改频率热力图**
   - 打开控制面板，切换到"🔥 热力图"标签页
   - 验证文件热力图显示：
     * 列出被修改过的文件
     * 颜色深浅表示修改次数（深色 = 频繁修改）
     * 支持按修改次数排序
   - **痛点解决**：快速识别热点文件，重点关注
2. **验证贡献者活跃度热力图**
   - 验证贡献者统计显示：
     * 列出所有贡献者
     * 显示每个贡献者的提交数量
     * 颜色深浅表示活跃度
   - **痛点解决**：了解团队贡献分布，识别核心贡献者
3. **验证数据准确性**
   - 对比 `git log --stat` 和 `git shortlog -sn` 的输出
   - 验证热力图数据与 Git 命令结果一致
   - **痛点解决**：数据可信赖
4. **验证主题适配**
   - 在浅色/深色主题下验证颜色对比度
   - 验证所有文本清晰可读
   - **痛点解决**：适应不同主题

#### 痛点场景 4：提交历史列表（侧边栏历史视图）

**问题**：需要快速浏览最近的提交，了解项目最新动态。

1. **验证历史列表显示**
   - 在侧边栏查看"提交历史"视图
   - 验证每条提交显示：
     * 提交哈希（前 7-8 位）
     * 提交消息（首行）
     * 作者名称
     * 提交时间（相对时间，如"2 小时前"）
   - **痛点解决**：快速浏览最近提交
2. **验证提交详情**
   - 点击某条提交
   - 验证显示完整信息：
     * 完整提交哈希
     * 完整提交消息
     * 作者和提交者信息
     * 文件变更列表
     * 增删行数统计
   - **痛点解决**：深入了解提交内容
3. **验证列表刷新**
   - 创建新提交后，验证历史列表自动更新
   - 或点击刷新按钮，验证列表更新
   - **痛点解决**：实时反映最新状态
4. **验证历史数量配置**
   - 修改配置 `git-assistant.maxHistoryCount`
   - 验证历史列表显示数量符合配置
   - **痛点解决**：可自定义显示数量

#### 痛点场景 5：数据一致性验证

**问题**：可视化数据需要与实际 Git 仓库状态一致。

1. **验证提交图谱数据**
   - 执行 `git log --oneline --graph --all`
   - 对比 2D 提交图谱显示
   - 验证：
     * 提交数量一致
     * 分支关系一致
     * 合并提交正确显示
2. **验证时间线数据**
   - 执行 `git log --format="%ad" --date=short | sort | uniq -c`
   - 对比时间线日历热力图
   - 验证每日提交数量一致
3. **验证热力图数据**
   - 执行 `git log --stat --oneline`
   - 对比文件修改频率热力图
   - 验证热点文件排名一致
4. **验证实时更新**
   - 在外部终端创建新提交
   - 刷新控制面板
   - 验证所有视图数据更新
   - **痛点解决**：数据始终与仓库同步

#### 痛点场景 6：边界情况处理

1. **空仓库**
   - 在只有初始提交的仓库中测试
   - 验证各视图显示友好提示或最小数据
2. **单分支仓库**
   - 在只有 main 分支的仓库中测试
   - 验证提交图谱正确显示线性历史
3. **大量分支**
   - 在有 20+ 分支的仓库中测试
   - 验证提交图谱性能和可读性
4. **长时间跨度**
   - 在有 1 年以上历史的仓库中测试
   - 验证时间线视图正确处理长时间跨度
5. **特殊字符**
   - 提交消息包含中文、emoji、特殊字符
   - 验证正确显示，无乱码

#### 提交历史与分析验证清单

**2D 提交图谱**

- [ ] 提交节点正确显示
- [ ] 分支关系连线正确
- [ ] 高 DPI 渲染清晰
- [ ] 缩放功能正常
- [ ] 拖拽功能正常
- [ ] 悬停显示详情
- [ ] 大仓库性能良好

**时间线视图**

- [ ] 日历热力图正确显示
- [ ] 颜色深浅表示提交数量
- [ ] 年月切换功能正常
- [ ] 柱状图数据正确
- [ ] 浅色/深色主题适配

**热力图分析**

- [ ] 文件修改频率正确显示
- [ ] 贡献者活跃度正确显示
- [ ] 数据与 Git 命令结果一致
- [ ] 主题适配正常

**提交历史列表**

- [ ] 提交信息完整显示
- [ ] 提交详情可查看
- [ ] 列表自动刷新
- [ ] 历史数量可配置

**数据一致性**

- [ ] 提交图谱数据与 Git 一致
- [ ] 时间线数据与 Git 一致
- [ ] 热力图数据与 Git 一致
- [ ] 实时更新正常

**边界情况**

- [ ] 空仓库处理正常
- [ ] 单分支仓库处理正常
- [ ] 大量分支处理正常
- [ ] 长时间跨度处理正常
- [ ] 特殊字符显示正常

---

### 2.6.8 测试控制面板完整巡检

> **测试目标**：逐一检查控制面板 10 个标签页的功能完整性。

**测试步骤**：

1. **打开控制面板**
   - 运行 **Git Assistant: 打开控制面板**
   - 验证面板正常加载
2. **逐一检查标签页**

| 序号 | 标签页       | 检查项                       |
| ---- | ------------ | ---------------------------- |
| 1    | 📋 快捷指令   | 命令分类、历史记录、执行功能 |
| 2    | 📚 Git 指令集 | 命令列表、搜索、执行         |
| 3    | 🌿 分支管理   | 分支树、创建/切换/合并/删除  |
| 4    | ☁️ 远程仓库   | 远程列表、添加/编辑/删除     |
| 5    | 🏷️ 标签管理   | 标签列表、创建/推送/删除     |
| 6    | 🌳 分支视图   | 依赖图渲染、交互             |
| 7    | ⚠️ 冲突解决   | 冲突列表、解决功能           |
| 8    | 📊 提交图谱   | 图谱渲染、缩放、拖拽         |
| 9    | 📅 时间线     | 日历热力图、柱状图           |
| 10   | 🔥 热力图     | 文件热力图、贡献者统计       |


3. **标签页切换测试**
   - 快速在各标签页之间切换
   - 验证切换流畅，无闪烁
4. **数据同步测试**
   - 在一个标签页执行操作
   - 切换到相关标签页
   - 验证数据同步更新
5. **主题适配测试**
   - 切换 VS Code 主题（浅色/深色）
   - 验证所有标签页正确适配
6. **响应式布局测试**
   - 调整控制面板宽度
   - 验证内容自适应

**验证清单**：

- [ ] 📋 快捷指令功能正常
- [ ] 📚 Git 指令集功能正常
- [ ] 🌿 分支管理功能正常
- [ ] ☁️ 远程仓库功能正常
- [ ] 🏷️ 标签管理功能正常
- [ ] 🌳 分支视图功能正常
- [ ] ⚠️ 冲突解决功能正常
- [ ] 📊 提交图谱功能正常
- [ ] 📅 时间线功能正常
- [ ] 🔥 热力图功能正常
- [ ] 标签页切换流畅
- [ ] 数据同步正常
- [ ] 主题适配正常
- [ ] 响应式布局正常

---

### 2.6.9 端到端测试总结清单

**场景覆盖**

- [ ] 场景一：新项目初始化
- [ ] 场景二：日常开发工作流
- [ ] 场景三：多人协作模拟
- [ ] 场景四：版本发布流程
- [ ] 场景五：冲突解决完整流程
- [ ] 场景六：异常处理与恢复
- [ ] 场景七：跨平台兼容性
- [ ] 场景八：性能与压力测试
- [ ] 场景九：控制面板完整巡检

**关键功能验证**

- [ ] 仓库初始化流程完整
- [ ] 分支管理流程完整
- [ ] 远程同步流程完整
- [ ] 标签管理流程完整
- [ ] 冲突解决流程完整
- [ ] 异常处理友好
- [ ] 性能表现良好
- [ ] 10 个标签页功能正常

**回归测试建议**

+ 每次发布前执行场景一到五
+ 重大更新前执行全部场景
+ 使用自动化脚本记录测试结果

# 3. 调试技巧

## 3.1 断点调试

```typescript
context.subscriptions.push(
  vscode.commands.registerCommand('git-assistant.quickPush', async () => {
    debugger; // 在此设置断点
  })
);
```

## 3.2 调试控制台

+ 查看 `console.log` 输出
+ 执行表达式检查变量值

## 3.3 日志查看

+ `Ctrl+Shift+U` → Git Assistant 日志
+ 菜单：帮助 → 切换开发人员工具 → Console

## 3.4 Webview 调试

+ 打开控制面板
+ 右键 Webview → “打开开发者工具”
+ 使用 Chrome DevTools 进行排查

# 4. 验证清单

**基础**

- [ ] 扩展激活（输出日志提示成功）
- [ ] 侧边栏显示分支/历史/冲突视图
- [ ] 命令面板列出所有 Git Assistant 命令
- [ ] 快捷键 `Ctrl+Alt+P/L/B` 正常
- [ ] 控制面板可加载

**功能覆盖**

- [ ] 控制面板 **10 个标签**内容与顺序正确
- [ ] Git 指令集与快捷指令历史面板可用
- [ ] 快捷指令历史可重新执行任一命令
- [ ] 远程仓库管理覆盖添加/编辑/删除
- [ ] 标签管理命令覆盖创建/推送/删除
- [ ] "初始化仓库 → 添加远程 → 初始提交" 可在空目录闭环执行

**Git 操作**

- [ ] 查看状态、切换/创建/合并分支
- [ ] 拉取/推送操作成功
- [ ] 提交历史列表展示完整信息
- [ ] 冲突检测在有冲突时提示并可打开冲突解决器

**UI**

- [ ] 分支树正确标记当前/远程分支
- [ ] 2D 提交图谱、热力图、分支视图、时间线视图数据正确
- [ ] 控制面板按钮、刷新与操作提示正常

**错误处理**

- [ ] 非 Git 仓库时提示初始化
- [ ] Git 操作失败时展示错误信息
- [ ] 网络/认证错误打印日志且不中断扩展

# 5. 常见问题

| 问题           | 排查思路                                                     |
| -------------- | ------------------------------------------------------------ |
| 扩展未激活     | 确认 `workspaceContains:.git` 生效、当前文件夹包含 `.git`，或执行初始化 |
| 命令不可用     | 可能不在 Git 仓库内，先运行 `git init` 或 Git Assistant: 初始化仓库 |
| 侧边栏图标丢失 | 右键活动栏 → 勾选 **Git Assistant**                          |
| Webview 空白   | 重新编译 `npm run compile`，确保 `dist/extension.js` 与 `media/app.js`、`media/styles/*.css` 存在 |
| TS 类型错误    | 执行 `npm install --save-dev @types/vscode @types/node`      |

# 6. 参考与附录

**调试输出示例**

```plain
[Extension Host] Git Assistant 扩展已激活
[Git Assistant] INFO: 开始执行快速推送
```

**性能验证指标**

+ Extension Host 启动 < 500 ms
+ 内存占用 < 50 MB

**下一步**

+ 参阅 `docs/DEVELOPMENT.md`
+ 在 `src/` 中修改功能
+ 编写测试 / 优化性能
+ `vsce package` 打包

**需要帮助？**

1. `Ctrl+Shift+U` → Git Assistant 日志
2. VS Code 开发者工具 Console
3. 文档：`README_CN.md` / `docs/DEVELOPMENT.md`

调试愉快！🎉