# 🔍 Git Assistant 项目验证和调试完整指南

> **当前版本**：v1.0.0 | **最后更新**：2025-11-26

本指南帮助你快速验证 Git Assistant 扩展是否工作正常，并在出现问题时提供排查路径。

# 1. 前置检查

### 1.1 环境版本

在开始之前，确认以下工具版本满足要求：

- **Node.js 16+**

  ```powershell
  node --version
  ```

- **npm**

  ```powershell
  npm --version
  ```

- **Git**

  ```powershell
  git --version
  ```

- **VS Code 1.80+**

  ```powershell
  code --version
  ```

### 1.2 安装依赖

```powershell
cd E:\CodeGitAssistant
npm install
```

预期输出：`added XXX packages ...`

若安装失败，可尝试：

```powershell
Remove-Item node_modules -Recurse -Force
Remove-Item package-lock.json -Force
npm install
```

### 1.3 编译项目

- **单次编译**

  ```powershell
  npm run compile
  ```

- **监听模式（推荐开发时使用）**

  ```powershell
  npm run watch
  ```

预期输出：

```
webpack 5.x.x compiled successfully in xxx ms
asset extension.js xxx KiB [emitted]
asset webview.js xxx KiB [emitted]
```

出现错误时可追加 `--display-error-details` 查看细节：

```powershell
npm run compile -- --display-error-details
```

### 1.4 启动调试

- **方法 A：VS Code（推荐）**

  1. 在 VS Code 中打开 `E:\CodeGitAssistant`
  2. 终端运行 `npm run watch`
  3. 按 `F5`（或菜单：运行 → 启动调试）
  4. 弹出 `[Extension Development Host]` 窗口

- **方法 B：使用 `launch.json`**

  `.vscode/launch.json` 已配置：

  ```json
  {
    "name": "运行扩展",
    "type": "extensionHost",
    "request": "launch",
    "args": ["--extensionDevelopmentPath=${workspaceFolder}"]
  }
  ```

# 2. 功能验证

## 2.1 准备测试仓库

```powershell
mkdir E:\TestRepo
cd E:\TestRepo
git init
echo "# Test" > README.md
git add .
git commit -m "Initial commit"
code .
```

## 2.2 验证扩展激活

- `Ctrl+Shift+X` → 搜索 **Git Assistant** → 显示“已启用”
- `Ctrl+Shift+U` → 选择 **Git Assistant** 输出通道 → 日志显示“扩展已激活”

## 2.3 验证侧边栏

- 分支管理
- 提交历史
- 冲突检测

## 2.4 测试快捷键

| 快捷键       | 功能     | 预期结果               |
| ------------ | -------- | ---------------------- |
| `Ctrl+Alt+P` | 快速推送 | 弹出推送确认对话框     |
| `Ctrl+Alt+L` | 快速拉取 | 开始拉取操作           |
| `Ctrl+Alt+B` | 切换分支 | 显示分支列表并进行切换 |

**场景化验证**

1. **快速推送（Ctrl+Alt+P）**
   - 在当前分支制造一次提交：`git commit -am "shortcut push"`
   - 按下快捷键后确认弹窗中显示目标远程与分支信息
   - 在弹窗中选择“确认推送”，查看输出面板应出现“开始推送/推送成功”日志，并在侧边栏提交历史中看到该提交被标记为已同步

2. **快速拉取（Ctrl+Alt+L）**
   - 在远程仓库制造一条新提交（可在另一终端 `git commit && git push`）
   - 回到 VS Code，确保当前分支有对应远程追踪
   - 按下快捷键，观察通知提示“正在拉取”，完成后刷新提交历史/时间线视图确认新增提交已同步
   - 若产生冲突，输出面板与“冲突检测”视图应立即出现红色提示

3. **快速切换分支（Ctrl+Alt+B）**
   - 在 Git Assistant 侧边栏确认存在至少两个分支，如 `main` 与 `feature/shortcut-tests`
   - 按下快捷键，确认弹出的分支列表默认聚焦当前分支，可通过关键字实时过滤
   - 选择目标分支后，状态栏与控制面板“分支管理”标签页应立即更新，同时若新分支存在未提交更改，应弹出提醒
   - 使用 `git status` 验证工作区保持干净，确保切换过程中未残留临时文件

## 2.5 测试命令面板

> **测试目标**：验证所有 Git Assistant 命令在命令面板中正确注册、可被搜索并能正常执行。

### 2.5.1 命令列表完整性验证

`Ctrl+Shift+P` → 输入"Git Assistant" → 应展示全部命令：

| 命令 | 快捷键 | 预期行为 |
|------|--------|----------|
| Git Assistant: 快速推送 (Push) | `Ctrl+Alt+P` | 弹出推送确认，显示进度，成功/失败通知 |
| Git Assistant: 快速拉取 (Pull) | `Ctrl+Alt+L` | 检测未提交更改，可选 stash，显示进度 |
| Git Assistant: 克隆仓库 (Clone) | - | 输入远程地址，选择目录，显示克隆进度 |
| Git Assistant: 初始化仓库 (Init) | - | 在当前目录执行 `git init`，成功后刷新视图 |
| Git Assistant: 添加远程仓库 | - | 输入远程名称和地址，执行 `git remote add` |
| Git Assistant: 添加文件 (Add) | - | 选择一键全部或多选文件，执行 `git add` |
| Git Assistant: 提交更改 (Commit) | - | 输入提交信息，执行 `git commit`，可选推送 |
| Git Assistant: 创建分支 | - | 输入分支名（含校验），执行 `git checkout -b` |
| Git Assistant: 切换分支 | `Ctrl+Alt+B` | 显示分支列表，选择后切换，检测未提交更改 |
| Git Assistant: 合并分支 | - | 选择目标分支和合并策略（快进/三路） |
| Git Assistant: 查看提交历史 | - | 打开历史视图或跳转到控制面板 |
| Git Assistant: 解决冲突 | - | 打开冲突解决器或跳转到冲突标签页 |
| Git Assistant: 刷新分支列表 | - | 刷新侧边栏分支树视图 |
| Git Assistant: 打开控制面板 | - | 打开 Webview 控制面板 |

### 2.5.2 命令搜索与过滤验证

1. **模糊搜索**
   - 输入"push"，验证"Git Assistant: 快速推送"出现在结果中
   - 输入"分支"，验证所有分支相关命令出现
   - 输入"tag"，验证标签相关命令出现

2. **命令图标验证**
   - 验证每个命令有对应的图标（如 `$(cloud-upload)` 对应推送）
   - 图标应清晰可辨，符合语义

3. **命令描述验证**
   - 验证命令标题清晰描述功能
   - 中文标题应准确无歧义

### 2.5.3 命令执行场景验证

1. **Git 仓库内执行**
   - 在已初始化的 Git 仓库中执行各命令
   - 验证命令正常执行，无报错

2. **非 Git 仓库执行**
   - 在非 Git 目录中执行 Git 操作命令（如推送、拉取）
   - 验证弹出提示"当前文件夹不是 Git 仓库"或引导初始化

3. **无远程仓库执行推送**
   - 在没有配置远程的仓库中执行推送
   - 验证弹出提示"当前仓库没有配置远程仓库"

4. **有未提交更改时切换分支**
   - 修改文件但不提交，执行切换分支
   - 验证弹出提示选择：暂存并切换 / 放弃更改并切换 / 取消

### 2.5.4 命令面板验证清单

- [ ] 所有 Git Assistant 命令在命令面板中可见
- [ ] 命令可通过关键字搜索找到
- [ ] 命令图标和标题正确显示
- [ ] 快捷键绑定正确（`Ctrl+Alt+P/L/B`）
- [ ] 非 Git 仓库场景有友好提示
- [ ] 命令执行后有成功/失败反馈

## 2.6 测试控制面板

执行 **Git Assistant: 打开控制面板**，确认：

- 面板正常加载并显示仓库统计与快捷动作
- **10 个标签页**顺序为：📋 快捷指令 → 📚 Git 指令集 → 🌿 分支管理 → ☁️ 远程仓库 → 🏷️ 标签管理 → 🌳 分支依赖 → ⚠️ 冲突解决 → 📊 提交图谱 → 📅 时间线 → 🔥 热力图
- 各标签内容可加载并可交互

### 2.6.1 测试快捷指令

> **测试目标**：验证快捷指令标签页能有效解决程序员在日常 Git 操作中的常见痛点，如命令记忆困难、重复操作繁琐、执行状态不透明等。

#### 痛点场景 1：界面布局与导航

**问题**：Git 命令众多，新手难以找到需要的功能，老手需要快速定位常用命令。

1. **界面布局验证**
   - 打开控制面板，切换到"📋 快捷指令"标签页（第一个标签）
   - 确认页面包含以下部分：
     - 顶部标题"快捷指令"
     - "🗑️ 清除历史记录"按钮（位于页面右上角）
     - 左侧：命令历史记录区域（显示最近执行的命令）
     - 右侧：可用命令列表区域（按分类折叠/展开显示）
   - **痛点解决**：清晰的布局让用户快速定位历史和可用命令

2. **命令分类显示**
   - 验证以下分类存在并按顺序显示：

     | 分类 | 图标 | 包含命令 |
     |------|------|----------|
     | 开始使用 | 🚀 | 初始化仓库、克隆仓库 |
     | 配置仓库 | ⚙️ | 添加远程仓库、添加文件、提交更改 |
     | 同步操作 | 🔄 | 快速推送、快速拉取 |
     | 分支管理 | 🌿 | 创建分支、切换分支、合并分支 |
     | 标签管理 | 🏷️ | 创建标签、查看标签列表、删除标签、推送标签 |
     | 查看操作 | 📊 | 查看提交历史、刷新分支列表 |
     | 冲突处理 | ⚠️ | 解决冲突 |
     | 工具 | 🛠️ | 打开控制面板 |

   - 默认展开分类：确认"开始使用"和"工具"分类默认展开，其他分类可折叠
   - 点击分类标题验证折叠/展开功能正常
   - **痛点解决**：按功能分类，快速找到需要的命令

3. **命令搜索与过滤（如果有）**
   - 如果提供搜索框，验证：
     - 输入关键字可过滤命令列表
     - 支持中文和英文搜索
     - 搜索结果实时更新
   - **痛点解决**：快速定位特定命令

#### 痛点场景 2：命令可用性智能判断

**问题**：在不同仓库状态下执行不适用的命令会报错，用户需要提前知道哪些命令可用。

1. **非 Git 仓库场景**
   - 在非 Git 目录打开控制面板，验证：
     - "🚀 开始使用"分类中的命令显示为**可用状态**（正常颜色）
     - "⚙️ 配置仓库"及之后分类中的命令显示为**禁用状态**（灰色）
     - 尝试点击禁用命令，确认无响应或提示"请先初始化仓库"
   - **痛点解决**：避免执行无效命令，引导用户先初始化

2. **已初始化但无提交场景**
   - 执行 `git init` 后，验证：
     - "⚙️ 配置仓库"分类的命令变为可用
     - "🔄 同步操作""🌿 分支管理""🏷️ 标签管理"仍为禁用（需要至少一次提交）
   - **痛点解决**：明确告知用户需要先提交

3. **已有提交场景**
   - 创建初始提交后，验证所有需要"commits"的命令变为可用
   - 执行 `git push` 或 `git pull` 后，确认相关命令图标和状态正常
   - **痛点解决**：所有功能解锁，可以正常使用

4. **无远程仓库场景**
   - 在没有配置远程的仓库中，验证：
     - "快速推送""快速拉取"命令显示为禁用或点击时提示配置远程
   - **痛点解决**：避免推送/拉取失败，引导配置远程

#### 痛点场景 3：命令历史记录功能

**问题**：经常需要重复执行相同的 Git 操作，每次都要重新输入参数很繁琐。

1. **执行命令并观察历史**
   - 依次执行以下命令，观察历史记录区域实时更新：
     1. **Git Assistant: 初始化仓库** → 应显示成功状态（✅）和时间戳
     2. **Git Assistant: 添加远程仓库** → 输入测试远程地址，确认记录成功
     3. **Git Assistant: 提交更改** → 创建提交后，历史记录显示提交信息
     4. **Git Assistant: 快速推送** → 推送成功后，记录显示推送状态
   - 验证每条历史记录包含：
     - 命令图标和名称
     - 执行时间（如"刚刚""2分钟前""1小时前"等相对时间）
     - 成功/失败状态指示（✅ 或 ❌）
     - 失败时显示错误信息
   - **痛点解决**：清晰的执行记录，便于追溯和复盘

2. **历史记录顺序**
   - 确认最新执行的命令显示在列表顶部
   - 最多显示最近 20 条记录（超过 20 条时，旧记录不显示但保留在存储中）
   - **痛点解决**：最新操作最先看到

3. **重新执行历史命令**
   - 在历史记录区域点击任意一条成功执行的命令
   - 确认命令被重新执行，并生成新的历史记录条目
   - 若命令需要用户输入（如分支名称、提交信息），应弹出输入框
   - 验证重新执行失败的命令时，错误提示正常显示
   - **痛点解决**：一键重复执行，无需重新输入

4. **复制命令（如果有）**
   - 如果提供复制功能，验证：
     - 可以复制命令对应的 Git 命令行
     - 复制到剪贴板后可在终端粘贴执行
   - **痛点解决**：学习 Git 命令行语法

#### 痛点场景 4：清除历史记录

**问题**：历史记录过多时需要清理，但又担心误操作。

1. **清除操作验证**
   - 点击"🗑️ 清除历史记录"按钮
   - 确认弹出确认对话框（如"确定要清除所有历史记录吗？"）
   - 确认清除后，历史记录区域应为空
   - 验证清除操作不影响可用命令列表
   - 执行新命令后，历史记录重新开始记录
   - **痛点解决**：安全清除，带确认防止误操作

2. **取消清除**
   - 点击清除按钮后，在确认对话框中选择"取消"
   - 验证历史记录保持不变
   - **痛点解决**：提供反悔机会

#### 痛点场景 5：命令执行反馈

**问题**：执行 Git 命令后不确定是否成功，需要手动检查状态。

1. **成功执行反馈**
   - 执行任意命令（如"快速推送"），确认：
     - 历史记录立即添加新条目，状态为成功（✅）
     - 控制面板数据自动刷新（如分支列表、提交历史等）
     - 相关 UI 元素（侧边栏、状态栏）同步更新
     - VS Code 通知区域显示成功提示
   - **痛点解决**：即时反馈，确认操作成功

2. **执行失败反馈**
   - 制造失败场景（如无远程仓库时执行推送），确认：
     - 历史记录显示失败状态（❌）和错误信息
     - 错误信息完整可读，包含失败原因
     - VS Code 通知区域显示错误提示
     - 不会中断扩展运行，其他功能仍可正常使用
   - **痛点解决**：明确的错误提示，便于排查问题

3. **执行中状态**
   - 执行耗时命令（如克隆大型仓库），确认：
     - 显示加载状态或进度指示
     - 相关按钮禁用，防止重复点击
     - 完成后恢复正常状态
   - **痛点解决**：知道命令正在执行中

#### 痛点场景 6：跨标签页集成验证

**问题**：在快捷指令中执行操作后，需要切换到其他标签页查看结果。

1. **分支操作集成**
   - 在"快捷指令"中执行"创建分支"，验证：
     - 切换到"🌿 分支管理"标签页，新分支应出现在分支树中
     - 切换到"🌳 分支依赖"标签页，分支关系图应更新
   - **痛点解决**：数据自动同步，无需手动刷新

2. **推送操作集成**
   - 在"快捷指令"中执行"快速推送"，验证：
     - 切换到"📊 提交图谱"标签页，相关提交节点状态更新
     - 切换到"📅 时间线"标签页，推送时间点应显示
   - **痛点解决**：操作结果在所有视图同步

3. **标签操作集成**
   - 在"快捷指令"中执行"创建标签"，验证：
     - 切换到"🏷️ 标签管理"标签页，新标签应出现在列表中
   - **痛点解决**：标签数据实时同步

4. **远程操作集成**
   - 在"快捷指令"中执行"添加远程仓库"，验证：
     - 切换到"☁️ 远程仓库"标签页，新远程应出现在列表中
   - **痛点解决**：远程配置实时同步

#### 痛点场景 7：边界场景测试

1. **历史记录上限**
   - 快速连续执行 50+ 条命令，确认历史记录保持在最多 20 条显示
   - 清除后重新执行，验证记录计数从 0 开始
   - **痛点解决**：避免历史记录无限增长

2. **并发执行**
   - 快速点击多个命令按钮，验证：
     - 命令按顺序执行，不会并发冲突
     - 每条命令的执行结果都正确记录到历史
   - **痛点解决**：防止操作冲突

3. **网络异常**
   - 断网后执行推送/拉取命令，验证：
     - 显示网络错误提示
     - 历史记录显示失败状态
     - 恢复网络后可重新执行
   - **痛点解决**：网络问题有友好提示

#### 痛点场景 8：UI/UX 细节验证

1. **命令描述**
   - 悬停在命令项上时，显示完整描述信息
   - 描述应清晰说明命令的作用
   - **痛点解决**：新手可以了解命令用途

2. **图标一致性**
   - 确认各分类和命令的图标显示正常，符合语义
   - 图标在不同主题下清晰可辨
   - **痛点解决**：视觉一致性

3. **响应式布局**
   - 调整控制面板宽度，验证命令列表和历史记录区域自适应
   - 窄屏时内容不会溢出或重叠
   - **痛点解决**：适应不同屏幕尺寸

4. **主题适配**
   - 在浅色主题和深色主题下，验证：
     - 命令的可用/禁用状态清晰可辨
     - 成功/失败状态颜色对比度足够
     - 所有文本清晰可读
   - **痛点解决**：适应用户主题偏好

#### 快捷指令验证清单

**基础功能**
- [ ] 界面布局正确（历史区域 + 命令列表）
- [ ] 命令分类显示正确（8 个分类）
- [ ] 分类折叠/展开功能正常
- [ ] 命令可用性基于仓库状态正确判断
- [ ] 历史记录正确显示执行时间和状态
- [ ] 重新执行历史命令功能正常
- [ ] 清除历史记录功能正常（带确认）

**痛点解决验证**
- [ ] 命令分类清晰，易于查找
- [ ] 禁用命令有明确提示
- [ ] 历史记录便于复盘和重复执行
- [ ] 成功/失败反馈即时且清晰
- [ ] 跨标签页数据同步正常
- [ ] 边界场景处理优雅

**UI/UX**
- [ ] 命令描述清晰
- [ ] 图标一致且符合语义
- [ ] 响应式布局正常
- [ ] 浅色/深色主题适配

### 2.6.2 测试分支管理

> **测试目标**：验证分支管理视图（侧边栏 + 控制面板“🌿 分支管理”标签页）在多分支协作场景下的可视化、操作与安全防护能力，确保从创建、切换、合并到清理的完整生命周期体验顺畅。

#### 痛点场景 1：分支树可视化与信息密度

**问题**：大型项目分支众多，难以快速了解当前状态、远程追踪和未合并分支。

1. **准备工作**
   - 切换到已有仓库的 `main` 分支，确保 `git status` 显示 clean
   - 打开控制面板“🌿 分支管理”标签页，同时展开侧边栏分支树

2. **布局与信息验证**
   - 验证分支树的区域包含：
     - 当前分支高亮（带 `✓` 或高亮背景）
     - 本地分支列表（按字母或更新时间排序）
     - 远程分支折叠面板（`origin`, `upstream` 等）
     - 快捷操作按钮：创建、切换、合并、删除、刷新
   - 鼠标悬停在分支项上，验证 tooltip 显示：
     - 完整分支名（如 `feature/branch-tests`）
     - 最后提交作者/时间/摘要
     - 远程追踪状态（已跟踪/未跟踪/落后/领先）

3. **筛选与搜索（如支持）**
   - 在分支列表上方输入关键字（如 `feature/`）
   - 验证列表实时过滤，支持模糊匹配
   - 清空搜索框后列表恢复

#### 痛点场景 2：规范创建与命名校验

**问题**：命令行创建分支时容易写错命名、忘记校验，导致命名不统一。

1. **创建标准分支**
   - 执行 **Git Assistant: 创建分支**，输入 `feature/branch-tests`
   - 验证：
     - 成功通知（含新分支名称）
     - 分支树即时出现新分支，并显示“未推送”状态
     - 命令历史记录新增“创建分支”条目

2. **命名校验**
   - 尝试输入非法名称（如 `feature branch` 或 `Feature@1`）
   - 验证弹窗提示命名规范（仅允许 `a-z0-9/-_` 等）
   - 确认不会创建非法分支

3. **重复名称处理**
   - 尝试创建已存在的分支
   - 验证弹窗提示“分支已存在”，阻止重复

#### 痛点场景 3：安全切换与工作区保护

**问题**：切换分支时忘记清理未提交更改，容易造成冲突或数据丢失。

1. **干净工作区切换**
   - 使用 `Ctrl+Alt+B` 或命令面板切换到 `feature/branch-tests`
   - 验证：
     - 控制面板、状态栏、侧边栏同步显示新分支
     - 瞬时切换，无额外提示

2. **脏工作区阻断**
   - 修改 `src/app.ts`（未提交）
   - 再次尝试切换分支
   - 验证弹出选项：
     - 暂存并切换
     - 放弃更改并切换
     - 取消
   - 选择“取消”后保持在原分支

3. **自动暂存（如支持）**
   - 选择“暂存并切换”
   - 验证：
     - 自动执行 `git stash push` / `pop` 或等效操作
     - 切换完成后工作区恢复
     - 命令历史记录显示“自动暂存”动作

#### 痛点场景 4：远程追踪与推送

**问题**：分支需快速与远程关联并推送，避免忘记设置 upstream。

1. **推送新分支**
   - 在“快捷指令”或命令面板执行 **Git Assistant: 快速推送**
   - 验证：
     - 首次推送弹出“推送并设置 upstream”确认框
     - 推送成功后分支树显示远程图标（如 `origin ↔ local`）
     - 分支依赖视图出现 `feature/branch-tests ↔ origin/feature/branch-tests`

2. **落后/领先状态**
   - 在外部终端向远程分支追加提交
   - 刷新分支列表
   - 验证本地分支显示“落后 N 个提交”标签
   - 本地提交未推送时显示“领先 N 个提交”

3. **远程分支列表**
   - 展开 `origin` 节点
   - 验证远程分支与本地对应关系
   - 点击远程分支快速创建本地追踪分支

#### 痛点场景 5：合并策略与冲突预判

**问题**：合并方式多样，开发者需要明确是快进还是非快进，并在冲突发生前获得提示。

1. 快进合并（Fast-forward）

- 操作步骤：
  - 切回 `main` 分支
  - 在分支树中右键选择“合并到当前分支” → 选择 `feature/branch-tests`
- 验证项：
  - ✅ 弹出提示层：“检测到可快进合并”
  - ✅ 合并耗时短，无冲突提示
  - ✅ 提交历史**不产生新提交**（仅移动指针）
  - ✅ 控制面板“分支依赖”视图实时更新

2. 非快进合并（Three-way Merge）

- 操作步骤：
  - 创建 `feature/branch-tests-2` 并提交更改
  - 在 `main` 分支增加不同内容的提交（制造分叉）
  - 执行 **Git Assistant: 合并分支**，选择 `feature/branch-tests-2`
- 验证项：
  - ✅ 合并对话框显示：“将创建合并提交”
  - ✅ 若存在冲突，自动跳转至“⚠️ 冲突解决”标签页
  - ✅ 合并完成后，命令历史记录中标记“成功”或“失败”

3. 合并预检查（Merge Preview）

- **操作步骤**：在合并对话框中查看预览信息
- 验证项：
  - ✅ 显示即将合并的提交列表（含作者、摘要、时间）
  - ✅ 提供“仅模拟（--no-commit）”选项（如底层 Git 支持）

------

#### 痛点场景 6：分支清理与保护

**问题**：长期存在的冗余分支影响视图清晰度，误删未合并分支风险高。

1. 删除已合并分支

- **操作步骤**：在分支树右键 `feature/branch-tests` → “删除分支”
- 验证项：
  - ✅ 弹窗提示：“是否删除本地分支？是否同步删除远程分支？”
  - ✅ 勾选“同步删除远程”后，需输入分支名二次确认
  - ✅ 删除成功后，本地与远程分支列表同步刷新

2. 删除未合并分支

- **操作步骤**：对未合并分支执行删除操作
- 验证项：
  - ✅ 弹窗警告：“该分支尚未合并，删除可能导致代码丢失！”
  - ✅ 未勾选“强制删除”时，操作被阻止
  - ✅ 勾选后仍需二次确认（如输入 `delete` 或分支名）

3. 批量清理（如支持）

- **操作步骤**：在分支管理界面点击“清理已合并分支”
- 验证项：
  - ✅ 列出所有已合并的本地/远程分支
  - ✅ 支持多选/全选，逐个确认删除
  - ✅ 操作完成后展示汇总结果（成功/失败数量）

------

#### 痛点场景 7：跨视图联动与回归检查

1. 分支依赖联动

- **操作**：创建或删除分支后，切换至“🌳 分支依赖”视图
- **验证**：节点与连线实时更新，反映最新拓扑关系

2. 提交图谱联动

- **操作**：完成合并后，切换至“📊 提交图谱”视图
- **验证**：合并节点正确显示，分支颜色与标签同步更新

3. 命令历史记录

- 验证：
  - ✅ 所有关键操作（创建、切换、合并、删除）均记录在历史中
  - ✅ 点击任意历史记录可重放或查看详情

------

#### 分支管理验证清单

✅ 基础能力

-  分支树信息完整（区分本地/远程，高亮当前分支）
-  支持搜索与过滤（按名称、状态、作者等）
-  分支创建成功后即时显示
-  分支命名校验准确（非法字符、重复检测）
-  切换分支时保护未提交更改（自动暂存/提示）
-  自动暂存与恢复流程可用且可靠
-  推送时可设置 upstream（首次推送自动关联）
-  落后（behind）/领先（ahead）状态标记准确
-  快进与非快进合并流程可清晰区分
-  冲突发生时自动引导至冲突解决视图
-  删除已合并分支时可选同步删除远程
-  删除未合并分支需强制确认，防止误操作

✅ 痛点解决验证

-  分支信息可视化清晰（显示作者、最后提交时间、状态）
-  分支切换安全，避免工作区更改丢失
-  远程状态追踪无需命令行（自动 fetch 或手动刷新）
-  合并前可预览影响范围，冲突有明确指引
-  分支清理具备保护机制（合并状态识别 + 二次确认）
-  与“分支依赖”“提交图谱”等视图实时联动

✅ 边界/高级场景

-  大量分支（50+）时列表加载与渲染性能良好
-  支持多级路径分支名（如 `feature/payments/api`）正常展示与操作
-  同名但来自不同远程仓库的分支可清晰区分（如 `origin/main` vs `upstream/main`）
-  Detached HEAD 状态有明确提示，并提供“创建分支”或“返回主干”修复入口
-  对保护分支（如 `main`、`release/*`）的合并/删除操作需额外确认或权限控制

### 2.6.3 测试分支依赖

> **测试目标**：验证分支依赖关系图能有效解决程序员在 Git 协作中的常见痛点，如不清楚分支关系、难以识别已合并分支、无法追溯合并路径等。

#### 痛点场景 1：识别已合并和未合并的分支

**问题**：团队中分支很多，无法快速识别哪些分支已经合并到主分支，哪些还在开发中。

1. **准备测试数据**
   ```powershell
   # 创建模拟场景：已有主分支和多个功能分支
   git checkout main
   git checkout -b feature/user-auth
   echo "auth code" > src/auth.ts
   git commit -am "Add user authentication"
   git checkout main
   git merge feature/user-auth -m "Merge branch 'feature/user-auth'"
   
   git checkout -b feature/payment
   echo "payment code" > src/payment.ts
   git commit -am "Add payment feature"
   # 注意：此分支尚未合并到 main
   
   git checkout -b feature/notification
   echo "notify code" > src/notify.ts
   git commit -am "Add notification"
   git checkout main
   git merge feature/notification -m "Merge branch 'feature/notification'"
   ```

2. **验证合并关系显示**
   - 切换到控制面板“分支依赖”标签页
   - 验证图表中：
     - `feature/user-auth` → `main` 有一条合并连线（箭头指向 main）
     - `feature/notification` → `main` 有一条合并连线
     - `feature/payment` → `main` **没有连线**（表示未合并）
   - **痛点解决**：通过可视化连线，一眼识别哪些分支已合并，哪些待合并

3. **识别孤立分支**
   - 观察图表，确认没有任何合并连线的分支节点
   - 这些分支可能是：
     - 新创建但尚未合并的功能分支
     - 已经过时但未清理的分支
     - 实验性分支
   - **痛点解决**：快速发现需要关注或清理的分支

#### 痛点场景 2：理解复杂的合并路径和依赖关系

**问题**：在大型项目中，分支之间可能存在多层合并关系，难以理解分支的创建顺序和依赖链。

1. **创建多层合并场景**
   ```powershell
   git checkout main
   git checkout -b develop
   git checkout -b feature/api-v2
   echo "api v2" > src/api-v2.ts
   git commit -am "API v2 implementation"
   git checkout develop
   git merge feature/api-v2 -m "Merge branch 'feature/api-v2' into develop"
   
   git checkout develop
   git checkout -b feature/dashboard
   echo "dashboard" > src/dashboard.ts
   git commit -am "Add dashboard"
   git checkout develop
   git merge feature/dashboard -m "Merge branch 'feature/dashboard' into develop"
   
   git checkout main
   git merge develop -m "Merge branch 'develop' into main"
   ```

2. **验证依赖链显示**
   - 在分支依赖图中，验证：
     - `feature/api-v2` → `develop` 有连线
     - `feature/dashboard` → `develop` 有连线
     - `develop` → `main` 有连线
   - **痛点解决**：清晰看到分支的合并路径，理解代码流向（feature → develop → main）

3. **验证箭头方向**
   - 确认所有连线的箭头指向被合并的目标分支
   - 箭头从源分支指向目标分支（从 → 到）
   - **痛点解决**：准确理解合并方向，避免混淆

#### 痛点场景 3：当前分支状态的可视化标识

**问题**：切换分支后，容易忘记当前在哪个分支上工作，导致错误提交或合并。

1. **验证当前分支高亮**
   - 切换到不同分支（使用 `Ctrl+Alt+B` 或命令面板）
   - 在分支依赖图中验证：
     - 当前分支节点使用**蓝色高亮**（#4a90e2）
     - 当前分支节点有**虚线外圈**（pulse 动画效果）
     - 其他分支节点使用普通蓝色（#569cd6）
   - **痛点解决**：一目了然当前工作分支，避免操作错误

2. **动态更新验证**
   - 切换到 `feature/payment` 分支
   - 观察分支依赖图，确认节点高亮立即更新
   - 切换到 `main` 分支，确认高亮跟随切换
   - **痛点解决**：实时反馈，避免状态不一致

#### 痛点场景 4：多人协作时的分支状态追踪

**问题**：团队成员在多个分支并行开发，不清楚其他人的工作进度和分支状态。

1. **模拟多人协作场景**
   ```powershell
   # 模拟 Alice 的分支
   git checkout -b alice/feature-login
   echo "login by alice" > src/login.ts
   git commit -am "Implement login (Alice)"
   
   # 模拟 Bob 的分支
   git checkout main
   git checkout -b bob/feature-profile
   echo "profile by bob" > src/profile.ts
   git commit -am "Implement profile (Bob)"
   
   # Alice 先合并了
   git checkout main
   git merge alice/feature-login -m "Merge branch 'alice/feature-login'"
   
   # Bob 的分支还未合并
   ```

2. **验证多人分支可视化**
   - 在分支依赖图中，验证：
     - 能看到所有开发者的分支节点
     - 已合并的分支（`alice/feature-login`）有连线指向 `main`
     - 未合并的分支（`bob/feature-profile`）没有连线
   - **痛点解决**：快速了解团队工作状态，避免重复开发和冲突

3. **分支命名识别**
   - 确认分支节点标签清晰显示完整分支名
   - 长分支名自动截断（超过 15 个字符显示 "..."）
   - **痛点解决**：通过命名规范快速识别分支归属和用途

#### 痛点场景 5：冲突追溯和合并历史查看

**问题**：发生合并冲突时，难以快速了解冲突分支的来源和合并历史。

1. **创建冲突场景并验证**
   ```powershell
   git checkout main
   git checkout -b feature/conflict-source
   echo "version A" > src/config.ts
   git commit -am "Add config (source branch)"
   
   git checkout main
   echo "version B" > src/config.ts
   git commit -am "Update config (main branch)"
   
   git checkout feature/conflict-source
   git merge main  # 此时会产生冲突
   ```

2. **验证冲突分支的可视化**
   - 在分支依赖图中，即使存在冲突，也应显示：
     - `feature/conflict-source` 分支节点存在
     - 如果冲突已解决并合并，应显示合并连线
   - **痛点解决**：通过图形追溯冲突来源分支，理解冲突原因

3. **合并提交信息验证**
   - 查看连线的详细信息（如果有工具提示）
   - 确认合并记录中包含提交哈希
   - **痛点解决**：可以追溯到具体的合并提交，查看合并详情

#### 痛点场景 6：大型项目的分支结构理解

**问题**：项目分支数量多（20+ 分支），难以理解整体分支结构和组织方式。

1. **创建多分支场景**
   ```powershell
   # 创建多个功能分支
   for ($i=1; $i -le 10; $i++) {
       git checkout -b feature/task-$i
       echo "task $i" > src/task$i.ts
       git commit -am "Task $i implementation"
       git checkout main
       if ($i % 2 -eq 0) {
           git merge feature/task-$i -m "Merge branch 'feature/task-$i'"
       }
   }
   ```

2. **验证力导向图布局**
   - 分支依赖图应使用 D3.js 力导向布局
   - 验证：
     - 节点自动排列，避免重叠
     - 有合并关系的分支节点靠近显示
     - 孤立分支节点自动分离
     - 布局美观，易于阅读
   - **痛点解决**：即使分支很多，也能通过合理布局理解结构

3. **交互功能验证**
   - **拖拽节点**：
     - 点击并拖拽任意分支节点
     - 验证节点可以自由移动
     - 验证连线跟随节点移动
     - **痛点解决**：可以手动调整布局，突出关注的分支
   
   - **缩放功能**：
     - 使用鼠标滚轮向上滚动（放大）
     - 使用鼠标滚轮向下滚动（缩小）
     - 验证缩放范围：0.1倍到4倍
     - **痛点解决**：可以放大查看细节，或缩小查看全局
   
   - **平移功能**：
     - 点击并拖拽空白区域（非节点区域）
     - 验证整个图形可以平移
     - **痛点解决**：可以查看图形的不同区域，不受画布限制

#### 痛点场景 7：识别过时和可清理的分支

**问题**：项目维护过程中，积累了很多已合并但未删除的分支，占用空间且造成混乱。

1. **验证已合并分支的可识别性**
   - 在分支依赖图中，已合并到主分支的功能分支应：
     - 有清晰的合并连线指向主分支
     - 节点仍然显示（方便识别）
   - **痛点解决**：一眼看出哪些分支已合并，可以安全删除

2. **识别长时间未更新的分支**
   - 结合时间线和分支依赖图：
     - 查看分支依赖图中的分支节点
     - 切换到“时间线”标签页查看最后提交时间
     - 识别长时间没有活动且已合并的分支
   - **痛点解决**：识别可清理的过时分支，保持仓库整洁

#### 痛点场景 8：空仓库和边界情况处理

**问题**：在不同仓库状态下，工具应能优雅处理边界情况。

1. **空仓库验证**
   - 在只有初始提交的仓库中（无分支合并）
   - 打开分支依赖图，验证：
     - 显示所有分支节点（即使没有合并关系）
     - 如果没有合并记录，只显示分支节点，无连线
     - 显示友好的空状态提示："暂无分支数据"（当完全没有分支时）

2. **单一分支验证**
   - 仓库中只有一个分支（如 `main`）
   - 验证图表正确显示单个节点
   - 无连线是正常情况，不应报错

3. **无合并历史验证**
   - 创建多个分支但从未合并
   - 验证：
     - 所有分支节点都显示
     - 没有任何连线（符合实际情况）
     - 图表布局正常，节点不重叠

#### 痛点场景 9：性能和数据刷新

**问题**：执行 Git 操作后，可视化界面应及时更新，反映最新状态。

1. **实时更新验证**
   - 在分支依赖图中记录初始状态（分支数量和连线）
   - 执行以下操作，验证图表自动刷新：
     - **创建新分支**：`git checkout -b feature/new`
       - 验证新分支节点立即出现在图中
     - **合并分支**：`git merge feature/new`
       - 验证合并连线立即显示
     - **删除分支**：`git branch -d feature/new`
       - 验证分支节点从图中移除
     - **切换分支**：`git checkout main`
       - 验证当前分支高亮立即更新

2. **刷新按钮验证**
   - 如果控制面板有手动刷新按钮
   - 点击刷新，验证分支依赖图数据重新加载
   - 验证刷新不会丢失当前的缩放和平移状态（如可能）

3. **大数据量性能**
   - 创建 50+ 分支和多个合并关系
   - 验证：
     - 图表加载时间 < 2 秒
     - 交互（拖拽、缩放）流畅，无明显卡顿
     - 节点标签清晰可读

#### 痛点场景 10：图例和用户引导

**问题**：新用户可能不理解图表的含义和交互方式。

1. **图例验证**
   - 在分支依赖图右下角，验证图例存在：
     - **当前分支**：蓝色实心圆（#4a90e2）
     - **其他分支**：蓝色圆（#569cd6）
     - **合并关系**：带箭头的蓝色线条
   - **痛点解决**：新用户可以通过图例快速理解图表含义

2. **交互提示验证**
   - 在图表下方或旁边，验证存在交互提示：
     - "💡 提示：可以拖拽节点调整布局，使用鼠标滚轮缩放，拖拽空白区域平移"
   - **痛点解决**：用户知道如何与图表交互，提升使用体验

3. **空状态提示**
   - 当没有分支数据时，验证显示友好提示：
     - "📊 暂无分支数据，请确保仓库中有分支信息"
   - **痛点解决**：明确告知用户当前状态，避免困惑

#### 验证清单

**基础功能**
- [ ] 所有分支节点正确显示
- [ ] 合并关系连线正确显示（箭头方向正确）
- [ ] 当前分支高亮标识正常
- [ ] 图例和提示信息清晰

**痛点解决验证**
- [ ] 能够快速识别已合并和未合并的分支
- [ ] 能够理解复杂的分支依赖链
- [ ] 当前分支状态一目了然
- [ ] 多人协作分支状态清晰可见
- [ ] 冲突分支可以追溯到来源
- [ ] 大型项目的分支结构易于理解
- [ ] 过时分支可以识别
- [ ] 边界情况处理优雅

**交互功能**
- [ ] 节点拖拽功能正常
- [ ] 缩放功能正常（鼠标滚轮）
- [ ] 平移功能正常（拖拽空白区域）
- [ ] 交互流畅，无卡顿

**性能和数据**
- [ ] Git 操作后图表实时更新
- [ ] 大数据量（50+ 分支）性能良好
- [ ] 刷新机制正常工作



### 2.6.4 测试冲突解决

> **测试目标**：验证冲突解决功能能有效解决程序员在 Git 合并中遇到的常见痛点，如冲突检测不及时、冲突标记难以理解、不知道选择哪个版本、容易遗漏冲突文件等。

#### 痛点场景 1：实时冲突检测和即时提醒

**问题**：执行 `git merge` 或 `git pull` 后，冲突不会自动提醒，需要手动执行 `git status` 才能发现，导致遗漏冲突。

1. **触发冲突并验证实时检测**
   ```powershell
   # 准备冲突场景
   git checkout main
   git checkout -b feature/user-profile
   echo "function getUser() { return 'Alice'; }" > src/user.ts
   git commit -am "Add user profile feature"
   
   git checkout main
   echo "function getUser() { return 'Bob'; }" > src/user.ts
   git commit -am "Update user function"
   
   # 执行合并，触发冲突
   git checkout feature/user-profile
   git merge main
   ```

2. **验证自动冲突检测**
   - **侧边栏自动更新**：
     - 合并命令执行后，侧边栏“冲突检测”视图应**立即**显示红色警告图标 ⚠️
     - 冲突文件列表自动出现在侧边栏，无需手动刷新
     - 文件图标显示为警告状态（红色/黄色）
   
   - **控制面板自动刷新**：
     - 切换到控制面板“冲突解决”标签页
     - 验证页面顶部显示："发现 X 个冲突文件"
     - 冲突文件列表立即显示，无需点击刷新按钮
   
   - **编辑器高亮提示**：
     - 打开包含冲突的文件（如 `src/user.ts`）
     - 验证冲突区域自动高亮显示（红色背景或边框）
     - 验证冲突标记行（`<<<<<<<`, `=======`, `>>>>>>>`）有特殊标识
   
   - **痛点解决**：无需手动检查，冲突立即可见，避免遗漏

3. **状态栏和通知验证**
   - 验证 VS Code 状态栏显示合并状态（如果有）
   - 验证是否弹出通知提示："发现 X 个冲突文件，需要解决"
   - 点击通知应跳转到冲突解决界面

#### 痛点场景 2：理解冲突标记和代码对比

**问题**：Git 的冲突标记（`<<<<<<< HEAD`, `=======`, `>>>>>>> branch`）对新手不友好，难以理解当前版本和传入版本的区别。

1. **创建清晰的冲突示例**
   ```powershell
   git checkout main
   git checkout -b feature/api-refactor
   # 在当前分支修改
   echo @"
   // API Configuration
   const API_URL = 'https://api.example.com';
   const TIMEOUT = 5000;
   "@ | Out-File -Encoding utf8 src/config.ts
   git commit -am "Refactor API config"
   
   git checkout main
   # 在主分支有不同修改
   echo @"
   // API Settings
   const API_URL = 'https://api.production.com';
   const TIMEOUT = 3000;
   "@ | Out-File -Encoding utf8 src/config.ts
   git commit -am "Update API settings"
   
   git checkout feature/api-refactor
   git merge main
   ```

2. **验证冲突编辑器显示**
   - 在控制面板“冲突解决”标签页，点击冲突文件 `src/config.ts`
   - 点击“打开文件”按钮，验证：
     - 文件在编辑器中打开
     - 冲突区域有清晰的视觉分隔
     - 冲突标记（`<<<<<<< HEAD`, `=======`, `>>>>>>> main`）可见
   
   - **痛点解决**：即使不熟悉 Git 标记，也能通过界面理解冲突结构

3. **验证三栏对比视图（如果有）**
   - 如果扩展提供了三栏对比视图（当前/传入/合并结果）
   - 验证：
     - 左侧显示"当前更改"（HEAD 版本）
     - 中间显示"传入更改"（要合并的分支版本）
     - 右侧显示合并结果预览
   - **痛点解决**：并排对比，清晰理解两个版本的差异

#### 痛点场景 3：快速选择保留哪个版本的代码

**问题**：手动编辑冲突标记容易出错，不知道应该选择当前版本还是传入版本，或者需要合并两者。

1. **验证快速解决选项**
   - 在冲突解决界面，点击冲突文件展开操作选项
   - 验证存在三个快速解决按钮：
     - **"接受当前更改"**（←）：保留本地/当前分支的修改
     - **"接受传入更改"**（→）：使用要合并分支的修改
     - **"接受所有更改"**（↕）：合并两个版本的内容
   
   - **痛点解决**：一键选择，无需手动删除冲突标记

2. **测试快速解决流程**
   ```powershell
   # 已有冲突的情况下
   # 在 VS Code 冲突解决界面
   ```
   - 选择一个冲突文件（如 `src/config.ts`）
   - 点击"接受传入更改"按钮
   - 验证：
     - 冲突标记自动删除
     - 文件内容变为传入版本
     - 文件自动保存
     - 控制面板中该文件从冲突列表移除或标记为"已解决"
   
   - **痛点解决**：无需手动编辑，降低出错概率

3. **验证按钮描述清晰**
   - 验证每个按钮有清晰的图标和文字说明
   - 验证按钮有悬停提示，说明操作的具体含义
   - **痛点解决**：即使是新手，也能理解每个选项的作用

#### 痛点场景 4：处理多个冲突文件时的追踪和管理

**问题**：合并时可能有多个文件发生冲突，容易遗漏某个文件的冲突，导致合并不完整。

1. **创建多文件冲突场景**
   ```powershell
   git checkout main
   git checkout -b feature/multi-file-conflict
   
   # 修改多个文件
   echo "version A" > src/file1.ts
   echo "version A" > src/file2.ts
   echo "version A" > src/file3.ts
   git commit -am "Multiple file changes"
   
   git checkout main
   echo "version B" > src/file1.ts
   echo "version B" > src/file2.ts
   echo "version B" > src/file3.ts
   git commit -am "Different changes"
   
   git checkout feature/multi-file-conflict
   git merge main
   ```

2. **验证冲突列表管理**
   - 在控制面板“冲突解决”标签页，验证：
     - 显示所有冲突文件列表（`file1.ts`, `file2.ts`, `file3.ts`）
     - 每个文件显示完整路径
     - 已解决的文件有标识（如绿色勾选标记）
     - 未解决的文件突出显示（如红色警告图标）
   
   - **痛点解决**：一目了然所有冲突文件，不会遗漏

3. **逐个解决验证**
   - 点击第一个冲突文件，选择"接受当前更改"
   - 验证该文件在列表中标记为"已解决"
   - 验证冲突计数更新（如"发现 2 个冲突文件"）
   - 继续解决剩余冲突，验证每个文件的解决状态独立追踪
   - **痛点解决**：清晰的进度追踪，知道还有多少冲突待解决

4. **批量操作验证（如果有）**
   - 如果支持批量操作，验证：
     - "全部接受当前更改"按钮（谨慎使用）
     - "全部接受传入更改"按钮
     - 批量操作的确认对话框
   - **痛点解决**：特定场景下可以快速处理大量冲突

#### 痛点场景 5：解决冲突后的标记和提交流程

**问题**：解决冲突后容易忘记执行 `git add` 标记为已解决，或不知道如何完成合并提交。

1. **验证标记已解决功能**
   - 解决一个冲突文件后，验证：
     - 文件从冲突列表移除，或显示"已解决"状态
     - 侧边栏冲突计数减少
     - 可以执行 **Git Assistant: 标记冲突已解决** 命令
     - 执行后，`git status` 显示文件在暂存区（已 add）

2. **验证完成合并流程**
   ```powershell
   # 所有冲突解决后
   # 在扩展中完成合并
   ```
   - 解决所有冲突文件后，验证：
     - 控制面板显示"所有冲突已解决"提示
     - 提供"完成合并"或"提交合并"按钮/命令
     - 执行后自动创建合并提交
     - 提交信息包含合并信息（如 "Merge branch 'feature/xxx' into main"）
   
   - **痛点解决**：明确的流程指引，不会卡在合并中间状态

3. **验证放弃合并功能**
   - 如果冲突太复杂，想放弃合并，验证：
     - 存在"放弃合并"或"中止合并"按钮/命令
     - 执行后自动执行 `git merge --abort`
     - 工作区恢复到合并前的状态
     - 冲突标记全部清除
   - **痛点解决**：提供回退选项，避免陷入混乱状态

#### 痛点场景 6：复杂冲突和嵌套冲突的处理

**问题**：同一个文件可能有多个冲突区域，或者冲突代码嵌套复杂，难以逐个处理。

1. **创建多段冲突场景**
   ```powershell
   git checkout main
   git checkout -b feature/complex-conflict
   
   # 文件中有多个函数，在不同位置都有冲突
   echo @"
   function func1() {
       return 'version A - func1';
   }
   function func2() {
       return 'version A - func2';
   }
   function func3() {
       return 'version A - func3';
   }
   "@ | Out-File -Encoding utf8 src/utils.ts
   git commit -am "Multiple functions"
   
   git checkout main
   echo @"
   function func1() {
       return 'version B - func1';
   }
   function func2() {
       return 'version B - func2';
   }
   function func3() {
       return 'version B - func3';
   }
   "@ | Out-File -Encoding utf8 src/utils.ts
   git commit -am "Different implementations"
   
   git checkout feature/complex-conflict
   git merge main
   ```

2. **验证多段冲突处理**
   - 打开冲突文件，验证：
     - 每个冲突区域独立高亮显示
     - 可以使用"接受当前/传入/所有更改"逐个解决每个冲突
     - 解决一个冲突后，其他冲突区域仍然可见
     - 所有冲突解决后，文件可以正常保存

3. **验证嵌套冲突**
   - 如果冲突代码包含嵌套结构（如嵌套函数、对象等）
   - 验证冲突标记正确识别嵌套范围
   - 验证解决选项能正确处理嵌套结构
   - **痛点解决**：复杂代码结构也能正确处理

#### 痛点场景 7：二进制文件和特殊文件冲突

**问题**：图片、PDF 等二进制文件发生冲突时，无法通过文本编辑器解决，需要特殊处理。

1. **创建二进制文件冲突**
   ```powershell
   git checkout main
   git checkout -b feature/add-image
   # 创建一个图片文件（模拟）
   "binary content version A" | Out-File -Encoding binary src/logo.png
   git add src/logo.png
   git commit -m "Add logo A"
   
   git checkout main
   "binary content version B" | Out-File -Encoding binary src/logo.png
   git add src/logo.png
   git commit -m "Add logo B"
   
   git checkout feature/add-image
   git merge main
   ```

2. **验证二进制文件处理**
   - 在冲突列表中看到 `src/logo.png`
   - 点击该文件，验证：
     - 显示提示："二进制文件冲突，请手动选择版本"
     - 提供选项："保留当前版本"或"使用传入版本"
     - 无法直接编辑文件内容（这是正常的）
   
   - **痛点解决**：明确提示二进制文件需要特殊处理，避免用户困惑

3. **验证其他特殊文件**
   - 测试 JSON、XML、YAML 等格式文件的冲突处理
   - 验证特殊字符（如中文、emoji）在冲突标记中的显示
   - 验证大文件（>1MB）的冲突检测性能

#### 痛点场景 8：冲突来源追溯和上下文理解

**问题**：发生冲突时，不知道冲突是从哪个分支来的，或者不知道两个版本的修改背景。

1. **验证冲突信息显示**
   - 在冲突解决界面，验证显示：
     - 当前分支名称（HEAD 指向的分支）
     - 要合并的分支名称
     - 冲突文件的路径
   
   - **痛点解决**：清楚知道冲突的来源，便于决策

2. **验证提交信息追溯（如果有）**
   - 如果支持，验证可以查看：
     - 当前版本的提交信息和作者
     - 传入版本的提交信息和作者
     - 冲突引入的提交哈希
   - **痛点解决**：了解修改背景，做出更好的合并决策

3. **结合分支依赖图验证**
   - 切换到"分支依赖"标签页
   - 验证可以看到当前合并操作涉及的分支
   - 验证分支关系图能显示合并进行中的状态
   - **痛点解决**：在更大的上下文中理解冲突

#### 痛点场景 9：冲突解决后的验证和测试

**问题**：解决冲突后不确定是否正确，担心破坏了代码逻辑或引入了 bug。

1. **验证解决后的状态检查**
   - 所有冲突解决后，验证：
     - 文件可以正常保存
     - 没有残留的冲突标记（`<<<<<<<`, `=======`, `>>>>>>>`）
     - `git status` 显示文件在暂存区
     - 可以正常编译或运行语法检查（如果配置了）

2. **验证合并提交创建**
   - 完成合并后，验证：
     - 创建了合并提交
     - 提交信息正确
     - 提交历史中可以看到合并记录
     - 可以查看合并提交的详细信息

3. **验证回退机制**
   - 如果发现解决有误，验证可以：
     - 查看合并提交的差异（`git show`）
     - 如果需要，可以撤销合并提交（`git reset --hard HEAD~1`）
     - 重新开始合并流程
   - **痛点解决**：提供验证和回退路径，降低风险

#### 痛点场景 10：团队协作中的冲突预防和处理

**问题**：多人同时修改同一文件时容易产生冲突，需要提前了解潜在的冲突风险。

1. **验证冲突预防提示（如果有）**
   - 在拉取远程更改前，验证是否有提示：
     - "远程分支有新的提交，可能导致冲突"
     - 显示哪些文件在本地和远程都有修改
   
   - **痛点解决**：提前了解潜在冲突，做好准备

2. **验证合并前的预览（如果有）**
   - 执行合并前，验证是否可以预览：
     - 将要合并的提交列表
     - 可能受影响的文件列表
     - 预估的冲突文件
   
   - **痛点解决**：合并前评估影响，减少意外

3. **验证协作场景**
   ```powershell
   # 模拟团队协作
   # 开发者 A 的修改
   git checkout main
   git checkout -b alice/feature
   echo "Alice's code" > src/app.ts
   git commit -am "Alice's changes"
   git push origin alice/feature
   
   # 开发者 B 在本地修改同一文件
   git checkout main
   echo "Bob's code" > src/app.ts
   git commit -am "Bob's changes"
   
   # B 尝试合并 A 的分支
   git merge alice/feature
   ```
   - 验证冲突检测能正确识别团队协作场景
   - 验证解决冲突后，可以继续协作流程
   - **痛点解决**：支持团队协作的完整流程

#### 验证清单

**基础功能**
- [ ] 冲突检测实时且准确
- [ ] 冲突列表清晰显示所有冲突文件
- [ ] 冲突编辑器功能完整
- [ ] 快速解决选项（当前/传入/所有）正常工作
- [ ] 标记已解决功能正常
- [ ] 完成合并流程顺畅

**痛点解决验证**
- [ ] 无需手动检查，冲突立即可见
- [ ] 冲突标记清晰易懂
- [ ] 可以快速选择保留哪个版本
- [ ] 多个冲突文件不会遗漏
- [ ] 解决后流程清晰，不会卡住
- [ ] 复杂冲突也能正确处理
- [ ] 二进制文件有特殊处理
- [ ] 冲突来源信息清晰
- [ ] 解决后可以验证正确性
- [ ] 支持团队协作场景

**边界情况**
- [ ] 空冲突文件处理
- [ ] 只有空白字符差异的冲突
- [ ] 非常大的冲突文件性能
- [ ] 合并中止后的状态恢复
- [ ] 同时打开多个冲突文件的处理

**用户体验**
- [ ] 界面友好，提示清晰
- [ ] 操作流程符合直觉
- [ ] 错误提示有帮助性
- [ ] 性能良好，无明显延迟

### 2.6.5 测试远程仓库管理

> **测试目标**：验证远程仓库管理功能能有效解决程序员在 Git 协作中的常见痛点，如远程配置复杂、多远程管理混乱、URL 更新繁琐等。

#### 痛点场景 1：添加远程仓库

**问题**：新项目或 Fork 仓库需要配置远程地址，命令行操作容易出错。

1. **准备测试环境**
   ```powershell
   mkdir E:\RemoteTest
   cd E:\RemoteTest
   git init
   echo "# Remote Test" > README.md
   git add .
   git commit -m "Initial commit"
   code .
   ```

2. **验证添加远程功能**
   - 打开控制面板，切换到"☁️ 远程仓库"标签页
   - 确认显示"当前仓库还没有任何远程仓库"提示
   - 点击"➕ 添加远程仓库"按钮
   - 输入远程名称（如 `origin`）和地址（如 `https://github.com/user/repo.git`）
   - 验证：
     - 远程列表立即显示新添加的远程
     - 显示 fetch 和 push 地址
     - 执行 `git remote -v` 确认配置正确
   - **痛点解决**：可视化添加，无需记忆命令格式

3. **验证多远程场景**
   - 添加第二个远程（如 `upstream`，地址为原始仓库）
   - 验证远程列表显示两个远程，各自地址正确
   - **痛点解决**：清晰管理多个远程（如 Fork 工作流中的 origin 和 upstream）

#### 痛点场景 2：编辑远程仓库

**问题**：远程仓库 URL 变更（如从 HTTPS 切换到 SSH，或仓库迁移）需要手动执行 `git remote set-url`。

1. **验证编辑功能**
   - 在远程列表中，点击目标远程的"✏️"编辑按钮
   - 修改远程名称（如 `origin` → `main-remote`）
   - 修改远程地址（如切换到 SSH 格式 `git@github.com:user/repo.git`）
   - 点击确认，验证：
     - 远程名称和地址立即更新
     - `git remote -v` 显示新配置
   - **痛点解决**：可视化编辑，避免命令行出错

2. **验证仅修改名称**
   - 编辑远程，仅修改名称，保持 URL 不变
   - 验证名称更新，URL 保持不变

3. **验证仅修改 URL**
   - 编辑远程，仅修改 URL，保持名称不变
   - 验证 URL 更新，名称保持不变

#### 痛点场景 3：删除远程仓库

**问题**：不再需要的远程（如临时测试远程）需要清理，避免混乱。

1. **验证删除功能**
   - 在远程列表中，点击目标远程的"🗑️"删除按钮
   - 确认弹出确认对话框，显示警告信息
   - 点击"删除"确认
   - 验证：
     - 远程从列表中移除
     - `git remote -v` 不再显示该远程
   - **痛点解决**：安全删除，带确认防止误操作

2. **验证取消删除**
   - 点击删除按钮后，在确认对话框中选择"取消"
   - 验证远程仍然存在

#### 痛点场景 4：远程信息展示

**问题**：不清楚当前配置了哪些远程，以及它们的用途。

1. **验证信息展示**
   - 在远程仓库标签页，验证每个远程显示：
     - 远程名称（如 `origin`、`upstream`）
     - Fetch 地址
     - Push 地址（如果与 Fetch 不同）
   - **痛点解决**：一目了然所有远程配置

2. **验证空状态提示**
   - 在没有远程的仓库中，验证显示友好提示
   - 提示应引导用户添加远程

#### 验证清单

**基础功能**
- [ ] 添加远程仓库功能正常
- [ ] 编辑远程名称功能正常
- [ ] 编辑远程 URL 功能正常
- [ ] 删除远程仓库功能正常（带确认）
- [ ] 远程列表正确显示所有远程

**痛点解决验证**
- [ ] 可视化添加远程，无需记忆命令
- [ ] 支持多远程管理（origin + upstream）
- [ ] 可视化编辑远程配置
- [ ] 安全删除带确认对话框
- [ ] 远程信息展示清晰完整

**边界情况**
- [ ] 空仓库（无远程）显示友好提示
- [ ] 远程名称校验（不允许非法字符）
- [ ] 远程 URL 校验（必须是有效 Git 地址）
- [ ] 重复远程名称的处理

---

### 2.6.6 测试标签管理

> **测试目标**：验证标签管理功能能有效解决程序员在版本发布中的常见痛点，如标签创建繁琐、推送遗漏、批量操作困难等。

#### 痛点场景 1：创建标签

**问题**：版本发布时需要打标签，命令行操作繁琐，容易忘记添加注释。

1. **准备测试环境**
   ```powershell
   cd E:\TestRepo
   git checkout main
   echo "version 1.0" > version.txt
   git add .
   git commit -m "Prepare for v1.0.0 release"
   ```

2. **验证创建带注释标签**
   - 打开控制面板，切换到"🏷️ 标签管理"标签页
   - 点击"➕ 创建新标签"按钮
   - 输入标签名称：`v1.0.0`
   - 选择"带注释的标签"类型
   - 输入注释：`Release version 1.0.0`
   - 选择"当前提交"
   - 验证：
     - 标签列表立即显示新标签
     - 显示标签名称、提交哈希、注释、创建时间
     - 执行 `git tag -l` 确认标签存在
     - 执行 `git show v1.0.0` 确认注释正确
   - **痛点解决**：引导式创建，不会遗漏注释

3. **验证创建轻量标签**
   - 再次点击"➕ 创建新标签"
   - 输入标签名称：`v1.0.0-beta`
   - 选择"轻量级标签"类型
   - 验证标签创建成功，无注释信息
   - **痛点解决**：支持两种标签类型，满足不同需求

4. **验证指定提交打标签**
   - 点击"➕ 创建新标签"
   - 选择"指定提交"
   - 从提交列表中选择历史提交
   - 验证标签指向正确的提交
   - **痛点解决**：可以给历史版本补打标签

#### 痛点场景 2：推送标签

**问题**：`git push` 默认不推送标签，容易忘记单独推送，导致远程缺少版本标签。

1. **验证推送单个标签**
   - 在标签列表中，点击 `v1.0.0` 标签的"📤"推送按钮
   - 验证：
     - 显示推送进度
     - 推送成功后显示提示
     - 远程仓库可以看到该标签（`git ls-remote --tags origin`）
   - **痛点解决**：一键推送，不会遗漏

2. **验证推送所有标签**
   - 创建多个本地标签（如 `v1.0.1`、`v1.0.2`）
   - 点击"📤 推送所有标签"按钮
   - 确认弹出确认对话框
   - 点击确认，验证所有标签推送成功
   - **痛点解决**：批量推送，适合版本发布后的统一同步

3. **验证强制推送（覆盖远程标签）**
   - 修改本地 `v1.0.0` 标签指向不同提交：
     ```powershell
     git tag -d v1.0.0
     git tag -a v1.0.0 -m "Updated release" HEAD~1
     ```
   - 在标签管理中推送 `v1.0.0`
   - 验证提示远程已存在同名标签
   - 选择"强制推送（覆盖）"
   - 验证远程标签被更新
   - **痛点解决**：支持修正错误的版本标签

#### 痛点场景 3：删除标签

**问题**：错误创建的标签需要删除，同时要处理本地和远程的同步问题。

1. **验证删除本地标签**
   - 在标签列表中，点击目标标签的"🗑️"删除按钮
   - 选择"仅删除本地标签"
   - 验证：
     - 标签从列表中移除
     - `git tag -l` 不再显示该标签
     - 远程标签仍然存在（如果之前推送过）
   - **痛点解决**：明确区分本地和远程删除

2. **验证同时删除本地和远程标签**
   - 点击删除按钮
   - 选择"同时删除远程标签"
   - 验证：
     - 本地标签删除
     - 远程标签也被删除（`git ls-remote --tags origin` 确认）
   - **痛点解决**：一步完成本地和远程的清理

3. **验证删除确认**
   - 删除操作应弹出确认对话框
   - 显示警告信息（如"此操作无法撤销"）
   - 取消操作应保留标签
   - **痛点解决**：防止误删除重要版本标签

#### 痛点场景 4：标签列表和信息展示

**问题**：不清楚当前有哪些版本标签，以及它们的详细信息。

1. **验证标签列表展示**
   - 在标签管理标签页，验证显示：
     - 所有本地标签
     - 每个标签的名称
     - 指向的提交哈希（前 8 位）
     - 标签注释（如果有）
     - 创建时间
   - **痛点解决**：一目了然所有版本标签

2. **验证标签排序**
   - 验证标签按创建时间倒序排列（最新的在前）
   - **痛点解决**：快速找到最新版本

3. **验证空状态提示**
   - 在没有标签的仓库中，验证显示友好提示
   - 提示应引导用户创建第一个标签
   - **痛点解决**：新手友好

#### 痛点场景 5：标签操作的实时反馈

**问题**：标签操作后不确定是否成功，需要手动刷新或执行命令确认。

1. **验证创建反馈**
   - 创建标签后，验证：
     - 标签列表立即更新
     - 显示成功/失败状态指示
     - 失败时显示错误信息
   - **痛点解决**：即时反馈，无需手动刷新

2. **验证推送反馈**
   - 推送标签后，验证：
     - 显示推送进度
     - 成功/失败状态清晰
     - 网络错误有友好提示
   - **痛点解决**：知道推送是否成功

3. **验证删除反馈**
   - 删除标签后，验证：
     - 标签从列表中移除
     - 显示删除成功提示
   - **痛点解决**：确认删除操作完成

#### 验证清单

**基础功能**
- [ ] 创建带注释标签功能正常
- [ ] 创建轻量标签功能正常
- [ ] 指定提交打标签功能正常
- [ ] 推送单个标签功能正常
- [ ] 推送所有标签功能正常
- [ ] 强制推送（覆盖）功能正常
- [ ] 删除本地标签功能正常
- [ ] 删除本地+远程标签功能正常
- [ ] 标签列表正确显示所有标签

**痛点解决验证**
- [ ] 引导式创建，不会遗漏注释
- [ ] 支持带注释和轻量两种标签类型
- [ ] 可以给历史提交打标签
- [ ] 一键推送，不会遗漏
- [ ] 批量推送所有标签
- [ ] 支持强制覆盖远程标签
- [ ] 明确区分本地和远程删除
- [ ] 删除操作有确认对话框
- [ ] 标签信息展示完整（名称、哈希、注释、时间）
- [ ] 操作有即时反馈

**边界情况**
- [ ] 空仓库（无标签）显示友好提示
- [ ] 标签名称校验（不允许非法字符）
- [ ] 重复标签名称的处理
- [ ] 无远程仓库时推送的处理
- [ ] 网络错误时的友好提示

**性能验证**
- [ ] 标签列表加载速度（使用 `git for-each-ref` 批量获取）
- [ ] 大量标签（50+）时的性能

---

### 2.6.7 测试提交历史与分析

> **测试目标**：验证提交历史可视化功能能有效解决程序员在代码审查和项目分析中的常见痛点，如提交历史难以理解、分支关系不清晰、贡献统计困难等。

#### 痛点场景 1：2D 提交图谱（📊 提交图谱标签页）

**问题**：命令行 `git log --graph` 输出难以阅读，分支关系不直观，难以理解项目演进。

1. **准备测试数据**
   ```powershell
   cd E:\TestRepo
   git checkout main
   
   # 创建多个分支和提交，模拟真实项目
   git checkout -b feature/api
   echo "api v1" > src/api.ts
   git commit -am "Add API v1"
   echo "api v2" > src/api.ts
   git commit -am "Update API to v2"
   
   git checkout main
   git checkout -b feature/ui
   echo "ui component" > src/ui.tsx
   git commit -am "Add UI component"
   
   git checkout main
   git merge feature/api -m "Merge feature/api"
   git merge feature/ui -m "Merge feature/ui"
   ```

2. **验证图谱渲染**
   - 打开控制面板，切换到"📊 提交图谱"标签页
   - 验证：
     - 所有提交节点正确显示（圆形节点）
     - 分支关系连线正确（合并提交有多条父连线）
     - 当前分支的提交节点有高亮标识
     - 节点颜色区分不同分支
   - **痛点解决**：图形化展示，分支关系一目了然

3. **验证高 DPI 渲染**
   - 在高分辨率显示器上查看图谱
   - 验证：
     - 节点和连线清晰锐利，无模糊
     - 文字标签清晰可读
     - 自动适配设备像素比
   - **痛点解决**：高清显示，适配现代显示器

4. **验证交互功能**
   - **缩放**：
     - 使用鼠标滚轮向上滚动（放大）
     - 使用鼠标滚轮向下滚动（缩小）
     - 验证缩放范围合理（0.1x - 4x）
     - 缩放时节点和文字比例正确
   - **拖拽**：
     - 点击并拖拽空白区域，平移视图
     - 点击并拖拽节点，调整节点位置
     - 验证连线跟随节点移动
   - **悬停**：
     - 鼠标悬停在提交节点上
     - 验证显示提交详情（哈希、作者、时间、消息）
   - **点击**：
     - 点击提交节点
     - 验证显示完整提交信息或跳转到详情
   - **痛点解决**：交互式探索，深入了解每个提交

5. **验证提交信息显示**
   - 验证每个节点显示：
     - 提交哈希（前 7-8 位）
     - 提交消息（截断显示）
     - 作者信息
     - 提交时间（相对时间或绝对时间）
   - 验证文本换行处理正确（支持中英文混合）
   - **痛点解决**：关键信息一目了然

6. **验证大仓库性能**
   - 在有 100+ 提交的仓库中测试
   - 验证：
     - 图谱加载时间 < 2 秒
     - 交互（缩放、拖拽）流畅，无卡顿
     - 内存占用合理
   - **痛点解决**：大项目也能流畅使用

#### 痛点场景 2：时间线视图（📅 时间线标签页）

**问题**：难以了解项目的提交频率和活跃度，不知道团队什么时候最忙碌。

1. **验证日历热力图**
   - 打开控制面板，切换到"📅 时间线"标签页
   - 验证日历热力图显示：
     - 按月份展示日历网格
     - 每个日期方块颜色深浅表示提交数量
     - 颜色统一使用 #0e639c 色系
     - 无提交的日期显示浅色或空白
   - **痛点解决**：一眼看出项目活跃度分布

2. **验证年月切换**
   - 点击年份/月份切换按钮
   - 验证：
     - 可以查看历史月份的提交分布
     - 切换时数据正确更新
     - 当前月份有标识
   - **痛点解决**：回顾历史活跃度

3. **验证日期详情**
   - 点击某个有提交的日期方块
   - 验证显示该日期的提交列表或数量
   - **痛点解决**：深入了解特定日期的提交

4. **验证柱状图时间线**
   - 验证下方柱状图显示：
     - X 轴为日期
     - Y 轴为提交数量
     - 柱状图高度与提交数量成正比
   - 验证柱状图与日历热力图数据一致
   - **痛点解决**：直观展示提交趋势

5. **验证主题适配**
   - 在浅色主题下查看时间线
   - 在深色主题下查看时间线
   - 验证：
     - 颜色对比度足够，清晰可读
     - 自动适配主题切换
   - **痛点解决**：适应用户主题偏好

#### 痛点场景 3：热力图分析（🔥 热力图标签页）

**问题**：不知道哪些文件被频繁修改（热点文件），不清楚团队成员的贡献分布。

1. **验证文件修改频率热力图**
   - 打开控制面板，切换到"🔥 热力图"标签页
   - 验证文件热力图显示：
     - 列出被修改过的文件
     - 颜色深浅表示修改次数（深色 = 频繁修改）
     - 支持按修改次数排序
   - **痛点解决**：快速识别热点文件，重点关注

2. **验证贡献者活跃度热力图**
   - 验证贡献者统计显示：
     - 列出所有贡献者
     - 显示每个贡献者的提交数量
     - 颜色深浅表示活跃度
   - **痛点解决**：了解团队贡献分布，识别核心贡献者

3. **验证数据准确性**
   - 对比 `git log --stat` 和 `git shortlog -sn` 的输出
   - 验证热力图数据与 Git 命令结果一致
   - **痛点解决**：数据可信赖

4. **验证主题适配**
   - 在浅色/深色主题下验证颜色对比度
   - 验证所有文本清晰可读
   - **痛点解决**：适应不同主题

#### 痛点场景 4：提交历史列表（侧边栏历史视图）

**问题**：需要快速浏览最近的提交，了解项目最新动态。

1. **验证历史列表显示**
   - 在侧边栏查看"提交历史"视图
   - 验证每条提交显示：
     - 提交哈希（前 7-8 位）
     - 提交消息（首行）
     - 作者名称
     - 提交时间（相对时间，如"2 小时前"）
   - **痛点解决**：快速浏览最近提交

2. **验证提交详情**
   - 点击某条提交
   - 验证显示完整信息：
     - 完整提交哈希
     - 完整提交消息
     - 作者和提交者信息
     - 文件变更列表
     - 增删行数统计
   - **痛点解决**：深入了解提交内容

3. **验证列表刷新**
   - 创建新提交后，验证历史列表自动更新
   - 或点击刷新按钮，验证列表更新
   - **痛点解决**：实时反映最新状态

4. **验证历史数量配置**
   - 修改配置 `git-assistant.maxHistoryCount`
   - 验证历史列表显示数量符合配置
   - **痛点解决**：可自定义显示数量

#### 痛点场景 5：数据一致性验证

**问题**：可视化数据需要与实际 Git 仓库状态一致。

1. **验证提交图谱数据**
   - 执行 `git log --oneline --graph --all`
   - 对比 2D 提交图谱显示
   - 验证：
     - 提交数量一致
     - 分支关系一致
     - 合并提交正确显示

2. **验证时间线数据**
   - 执行 `git log --format="%ad" --date=short | sort | uniq -c`
   - 对比时间线日历热力图
   - 验证每日提交数量一致

3. **验证热力图数据**
   - 执行 `git log --stat --oneline`
   - 对比文件修改频率热力图
   - 验证热点文件排名一致

4. **验证实时更新**
   - 在外部终端创建新提交
   - 刷新控制面板
   - 验证所有视图数据更新
   - **痛点解决**：数据始终与仓库同步

#### 痛点场景 6：边界情况处理

1. **空仓库**
   - 在只有初始提交的仓库中测试
   - 验证各视图显示友好提示或最小数据

2. **单分支仓库**
   - 在只有 main 分支的仓库中测试
   - 验证提交图谱正确显示线性历史

3. **大量分支**
   - 在有 20+ 分支的仓库中测试
   - 验证提交图谱性能和可读性

4. **长时间跨度**
   - 在有 1 年以上历史的仓库中测试
   - 验证时间线视图正确处理长时间跨度

5. **特殊字符**
   - 提交消息包含中文、emoji、特殊字符
   - 验证正确显示，无乱码

#### 提交历史与分析验证清单

**2D 提交图谱**
- [ ] 提交节点正确显示
- [ ] 分支关系连线正确
- [ ] 高 DPI 渲染清晰
- [ ] 缩放功能正常
- [ ] 拖拽功能正常
- [ ] 悬停显示详情
- [ ] 大仓库性能良好

**时间线视图**
- [ ] 日历热力图正确显示
- [ ] 颜色深浅表示提交数量
- [ ] 年月切换功能正常
- [ ] 柱状图数据正确
- [ ] 浅色/深色主题适配

**热力图分析**
- [ ] 文件修改频率正确显示
- [ ] 贡献者活跃度正确显示
- [ ] 数据与 Git 命令结果一致
- [ ] 主题适配正常

**提交历史列表**
- [ ] 提交信息完整显示
- [ ] 提交详情可查看
- [ ] 列表自动刷新
- [ ] 历史数量可配置

**数据一致性**
- [ ] 提交图谱数据与 Git 一致
- [ ] 时间线数据与 Git 一致
- [ ] 热力图数据与 Git 一致
- [ ] 实时更新正常

**边界情况**
- [ ] 空仓库处理正常
- [ ] 单分支仓库处理正常
- [ ] 大量分支处理正常
- [ ] 长时间跨度处理正常
- [ ] 特殊字符显示正常

## 2.7 场景化端到端测试

> **测试目标**：通过模拟真实开发场景，验证 Git Assistant 在完整工作流中的表现，确保各功能模块协同工作正常。

---

### 2.7.1 场景一：新项目初始化

**场景描述**：开发者在空目录中创建新项目，从零开始配置 Git 仓库。

**前置条件**：
- 准备一个空目录（如 `E:\NewProject`）
- 确保 Git 已安装并配置用户信息

**测试步骤**：

1. **打开空目录**
   ```powershell
   mkdir E:\NewProject
   code E:\NewProject
   ```

2. **验证扩展激活**
   - 打开 VS Code 后，检查：
     - 侧边栏出现 Git Assistant 图标
     - 状态栏显示 Git 状态（应显示"非 Git 仓库"或类似提示）
     - 输出通道（`Ctrl+Shift+U`）显示"Git Assistant 已激活"

3. **初始化仓库**
   - 通过命令面板（`Ctrl+Shift+P`）运行 **Git Assistant: 初始化仓库**
   - 验证：
     - 弹出成功通知
     - 目录中生成 `.git` 文件夹
     - 侧边栏分支视图更新，显示 `main` 或 `master` 分支
     - 状态栏更新为当前分支名称

4. **创建初始文件**
   - 手动创建 `README.md` 文件：
     ```markdown
     # New Project
     This is a new project.
     ```

5. **添加文件到暂存区**
   - 运行 **Git Assistant: 添加文件**
   - 选择"一键全部"或选择 `README.md`
   - 验证：
     - 文件被添加到暂存区
     - 侧边栏显示暂存状态

6. **创建初始提交**
   - 运行 **Git Assistant: 提交更改**
   - 输入提交信息："Initial commit"
   - 验证：
     - 提交成功通知
     - 提交历史视图显示新提交
     - 控制面板"提交图谱"显示第一个节点

7. **配置远程仓库**
   - 运行 **Git Assistant: 添加远程仓库**
   - 输入远程名称：`origin`
   - 输入远程地址：`https://github.com/username/new-project.git`（或本地裸仓库）
   - 验证：
     - 成功通知
     - 控制面板"远程仓库"标签页显示新远程

8. **推送到远程**
   - 运行 **Git Assistant: 快速推送**（`Ctrl+Alt+P`）
   - 验证：
     - 推送进度显示
     - 成功通知
     - 远程仓库可见提交

**预期结果**：
- 从空目录到推送远程的完整流程顺畅
- 各步骤有清晰的反馈
- 命令历史记录完整

**验证清单**：
- [ ] 扩展在空目录正常激活
- [ ] 初始化仓库成功
- [ ] 添加文件成功
- [ ] 提交成功
- [ ] 添加远程成功
- [ ] 推送成功
- [ ] 命令历史记录完整

---

### 2.7.2 场景二：日常开发工作流

**场景描述**：开发者在已有项目中进行日常开发，包括创建分支、提交代码、推送更改。

**前置条件**：
- 已初始化的 Git 仓库
- 已配置远程仓库

**测试步骤**：

1. **查看当前状态**
   - 打开控制面板，切换到"分支管理"标签页
   - 验证当前分支显示正确

2. **创建功能分支**
   - 运行 **Git Assistant: 创建分支**
   - 输入分支名：`feature/user-auth`
   - 验证：
     - 分支创建成功
     - 自动切换到新分支
     - 侧边栏和状态栏更新

3. **开发新功能**
   - 创建新文件 `src/auth.ts`：
     ```typescript
     export class AuthService {
       login(username: string, password: string): boolean {
         // TODO: Implement login
         return true;
       }
     }
     ```
   - 修改 `README.md`，添加功能说明

4. **暂存并提交**
   - 运行 **Git Assistant: 添加文件** → 选择所有更改
   - 运行 **Git Assistant: 提交更改**
   - 输入提交信息："feat: Add user authentication service"
   - 验证：
     - 提交成功
     - 提交历史更新

5. **继续开发并多次提交**
   - 添加更多功能代码
   - 创建多个提交（如 "feat: Add login validation", "fix: Fix password check"）
   - 验证提交图谱显示多个节点

6. **推送功能分支**
   - 运行 **Git Assistant: 快速推送**
   - 验证推送成功

7. **切换回主分支**
   - 运行 **Git Assistant: 切换分支**（`Ctrl+Alt+B`）
   - 选择 `main` 分支
   - 验证切换成功

8. **合并功能分支**
   - 运行 **Git Assistant: 合并分支**
   - 选择 `feature/user-auth`
   - 选择合并策略（如"快进合并"）
   - 验证：
     - 合并成功
     - 提交历史显示合并结果
     - 分支依赖图更新

9. **推送主分支**
   - 运行 **Git Assistant: 快速推送**
   - 验证推送成功

10. **清理功能分支（可选）**
    - 在分支管理中删除 `feature/user-auth`
    - 验证删除成功

**预期结果**：
- 完整的功能开发流程顺畅
- 分支创建、切换、合并正常
- 提交和推送正常

**验证清单**：
- [ ] 创建功能分支成功
- [ ] 多次提交成功
- [ ] 推送功能分支成功
- [ ] 切换分支成功
- [ ] 合并分支成功
- [ ] 推送主分支成功
- [ ] 提交图谱正确显示分支和合并

---

### 2.7.3 场景三：多人协作模拟

**场景描述**：模拟团队协作场景，处理远程更新和本地更改的同步。

**前置条件**：
- 已配置远程仓库
- 准备一个外部终端模拟"同事"的操作

**测试步骤**：

1. **模拟同事推送更改**
   - 在外部终端（模拟同事）：
     ```powershell
     cd E:\TestRepo
     git checkout main
     echo "Colleague's change" >> colleague.txt
     git add .
     git commit -m "feat: Add colleague feature"
     git push origin main
     ```

2. **本地拉取更新**
   - 在 VS Code 中运行 **Git Assistant: 快速拉取**（`Ctrl+Alt+L`）
   - 验证：
     - 拉取成功通知
     - 本地出现 `colleague.txt` 文件
     - 提交历史显示同事的提交

3. **本地同时有更改**
   - 在本地创建新文件 `local.txt`
   - 运行拉取命令
   - 验证：
     - 如果有未提交更改，弹出提示选择处理方式
     - 可选择暂存（stash）后拉取

4. **处理分支落后情况**
   - 模拟同事再次推送：
     ```powershell
     echo "Another change" >> colleague.txt
     git commit -am "feat: Update colleague feature"
     git push origin main
     ```
   - 本地创建提交但不推送
   - 运行推送命令
   - 验证：
     - 提示本地分支落后于远程
     - 建议先拉取再推送

5. **验证分支依赖图更新**
   - 打开控制面板"分支依赖"标签页
   - 验证远程分支和本地分支关系正确显示

6. **验证远程仓库视图**
   - 打开控制面板"远程仓库"标签页
   - 验证远程信息正确显示

**预期结果**：
- 拉取远程更新正常
- 本地有更改时有友好提示
- 分支落后时有正确引导

**验证清单**：
- [ ] 拉取远程更新成功
- [ ] 本地有未提交更改时有提示
- [ ] 分支落后时有正确提示
- [ ] 分支依赖图正确更新
- [ ] 远程仓库视图正确显示

---

### 2.7.4 场景四：版本发布流程

**场景描述**：开发者完成功能开发后，进行版本发布，包括创建标签和推送。

**前置条件**：
- 已有多个提交的仓库
- 已配置远程仓库

**测试步骤**：

1. **确认发布准备**
   - 查看提交历史，确认要发布的功能已合并到主分支
   - 查看分支依赖图，确认没有未合并的功能分支

2. **创建版本标签**
   - 打开控制面板"标签管理"标签页
   - 点击"➕ 创建新标签"
   - 输入标签名：`v1.0.0`
   - 选择"带注释的标签"
   - 输入注释：
     ```
     Release v1.0.0
     
     Features:
     - User authentication
     - Basic API endpoints
     
     Bug fixes:
     - Fixed login validation
     ```
   - 验证标签创建成功

3. **推送标签到远程**
   - 点击标签的"📤"推送按钮
   - 验证：
     - 推送成功通知
     - 远程仓库可见标签（`git ls-remote --tags origin`）

4. **验证标签在各视图显示**
   - 提交图谱：标签对应的提交节点应有标签标识
   - 时间线：标签时间点应有标记
   - 标签列表：显示标签详情

5. **创建热修复分支（可选）**
   - 从标签创建修复分支：`hotfix/v1.0.1`
   - 修复问题并提交
   - 创建新标签 `v1.0.1`
   - 推送标签

6. **批量推送所有标签**
   - 创建多个本地标签
   - 点击"📤 推送所有标签"
   - 验证所有标签推送成功

**预期结果**：
- 版本发布流程顺畅
- 标签创建和推送正常
- 各视图正确显示标签信息

**验证清单**：
- [ ] 创建带注释标签成功
- [ ] 推送单个标签成功
- [ ] 远程可见标签
- [ ] 提交图谱显示标签
- [ ] 推送所有标签成功

---

### 2.7.5 场景五：冲突解决完整流程

**场景描述**：模拟合并冲突场景，使用冲突解决器解决冲突。

**前置条件**：
- 已初始化的 Git 仓库

**测试步骤**：

1. **准备冲突环境**
   ```powershell
   cd E:\TestRepo
   git checkout main
   
   # 创建共同祖先
   echo "Line 1: Original" > conflict.txt
   echo "Line 2: Original" >> conflict.txt
   git add .
   git commit -m "Add conflict.txt"
   
   # 创建分支 A 并修改
   git checkout -b branch-a
   echo "Line 1: Modified by A" > conflict.txt
   echo "Line 2: Original" >> conflict.txt
   git commit -am "Modify line 1 in branch A"
   
   # 创建分支 B 并修改同一行
   git checkout main
   git checkout -b branch-b
   echo "Line 1: Modified by B" > conflict.txt
   echo "Line 2: Original" >> conflict.txt
   git commit -am "Modify line 1 in branch B"
   ```

2. **触发合并冲突**
   - 切换到 `branch-a`
   - 运行 **Git Assistant: 合并分支**
   - 选择 `branch-b`
   - 验证：
     - 弹出冲突提示
     - 冲突文件在编辑器中标记

3. **使用冲突解决器**
   - 打开控制面板"冲突解决"标签页
   - 验证：
     - 显示冲突文件列表
     - 每个文件显示冲突数量
   - 点击冲突文件
   - 验证：
     - 显示三路对比视图（当前分支、基础版本、目标分支）
     - 冲突区域高亮显示

4. **解决冲突**
   - 对于每个冲突，选择：
     - 接受当前分支更改
     - 接受目标分支更改
     - 手动编辑合并
   - 验证解决后冲突标记消失

5. **完成合并**
   - 所有冲突解决后，运行 **Git Assistant: 提交更改**
   - 验证：
     - 合并提交成功
     - 提交历史显示合并节点

6. **验证合并结果**
   - 查看 `conflict.txt` 内容
   - 确认内容符合预期
   - 查看提交图谱，确认合并关系正确

**预期结果**：
- 冲突检测正确
- 冲突解决器功能正常
- 合并完成后状态正确

**验证清单**：
- [ ] 冲突正确检测
- [ ] 冲突文件列表正确
- [ ] 三路对比视图正常
- [ ] 接受当前/目标更改功能正常
- [ ] 手动编辑功能正常
- [ ] 合并提交成功
- [ ] 提交图谱正确显示合并

---

### 2.7.6 场景六：异常处理与恢复

**场景描述**：测试各种异常情况下的错误处理和恢复能力。

**测试步骤**：

1. **网络异常**
   - 断开网络连接
   - 运行 **Git Assistant: 快速推送**
   - 验证：
     - 显示网络错误提示
     - 错误信息清晰可读
     - 扩展不崩溃，其他功能正常
   - 恢复网络，重新推送
   - 验证推送成功

2. **权限错误**
   - 尝试推送到没有写权限的仓库
   - 验证：
     - 显示权限错误提示
     - 引导用户检查凭证

3. **非 Git 目录操作**
   - 在非 Git 目录中运行 Git 命令
   - 验证：
     - 显示"请先初始化仓库"提示
     - 提供初始化选项

4. **远程不存在**
   - 在没有远程的仓库中运行推送
   - 验证：
     - 显示"未配置远程仓库"提示
     - 引导用户添加远程

5. **分支不存在**
   - 尝试切换到不存在的分支
   - 验证错误提示

6. **文件锁定**
   - 使用其他程序锁定 `.git` 目录中的文件
   - 运行 Git 操作
   - 验证错误处理

7. **大文件处理**
   - 添加一个大文件（如 100MB）
   - 运行提交和推送
   - 验证：
     - 显示进度
     - 处理超时情况

8. **并发操作**
   - 快速连续点击多个命令按钮
   - 验证：
     - 命令按顺序执行
     - 不会出现竞态条件

**预期结果**：
- 各种异常情况有友好提示
- 错误不会导致扩展崩溃
- 提供恢复建议

**验证清单**：
- [ ] 网络异常有友好提示
- [ ] 权限错误有友好提示
- [ ] 非 Git 目录有引导
- [ ] 远程不存在有引导
- [ ] 分支不存在有提示
- [ ] 文件锁定有提示
- [ ] 大文件处理正常
- [ ] 并发操作处理正常

---

### 2.7.7 场景七：跨平台兼容性

**场景描述**：验证扩展在不同操作系统上的兼容性。

**测试步骤**：

1. **Windows 测试**
   - 在 Windows 10/11 上安装扩展
   - 验证所有功能正常
   - 特别注意：
     - 路径分隔符处理（`\` vs `/`）
     - 文件权限处理
     - 换行符处理（CRLF vs LF）

2. **macOS 测试**（如有条件）
   - 在 macOS 上安装扩展
   - 验证所有功能正常
   - 特别注意：
     - 快捷键兼容性（`Cmd` vs `Ctrl`）
     - 文件系统大小写敏感性

3. **Linux 测试**（如有条件）
   - 在 Linux 上安装扩展
   - 验证所有功能正常
   - 特别注意：
     - 文件权限处理
     - 符号链接处理

4. **不同 VS Code 版本**
   - 在 VS Code 1.80+ 上测试
   - 在 VS Code Insiders 上测试
   - 验证兼容性

5. **不同 Git 版本**
   - 在 Git 2.0+ 上测试
   - 在最新 Git 版本上测试
   - 验证命令兼容性

**验证清单**：
- [ ] Windows 功能正常
- [ ] macOS 功能正常（如测试）
- [ ] Linux 功能正常（如测试）
- [ ] 不同 VS Code 版本兼容
- [ ] 不同 Git 版本兼容

---

### 2.7.8 场景八：性能与压力测试

**场景描述**：测试扩展在大型仓库和高负载下的性能表现。

**测试步骤**：

1. **大型仓库测试**
   - 克隆一个大型开源仓库（如 VS Code、React）
   - 验证：
     - 扩展激活时间 < 3 秒
     - 分支列表加载时间 < 2 秒
     - 提交图谱渲染时间 < 5 秒

2. **大量分支测试**
   - 在有 50+ 分支的仓库中测试
   - 验证：
     - 分支列表滚动流畅
     - 分支依赖图可读
     - 切换分支响应及时

3. **大量提交测试**
   - 在有 1000+ 提交的仓库中测试
   - 验证：
     - 提交历史分页加载
     - 提交图谱性能良好
     - 时间线视图响应及时

4. **大量标签测试**
   - 在有 100+ 标签的仓库中测试
   - 验证：
     - 标签列表加载速度
     - 批量操作性能

5. **内存占用监控**
   - 使用 VS Code 开发者工具监控内存
   - 验证：
     - 内存占用合理（< 200MB）
     - 无内存泄漏

6. **长时间运行**
   - 保持扩展运行 8 小时以上
   - 验证：
     - 功能稳定
     - 无性能退化
     - 无内存泄漏

**验证清单**：
- [ ] 大型仓库激活时间 < 3 秒
- [ ] 分支列表加载时间 < 2 秒
- [ ] 提交图谱渲染时间 < 5 秒
- [ ] 大量分支处理正常
- [ ] 大量提交处理正常
- [ ] 大量标签处理正常
- [ ] 内存占用合理
- [ ] 长时间运行稳定

---

### 2.7.9 场景九：控制面板完整巡检

**场景描述**：逐一检查控制面板 10 个标签页的功能完整性。

**测试步骤**：

1. **打开控制面板**
   - 运行 **Git Assistant: 打开控制面板**
   - 验证面板正常加载

2. **逐一检查标签页**

   | 序号 | 标签页 | 检查项 |
   |------|--------|--------|
   | 1 | 📋 快捷指令 | 命令分类、历史记录、执行功能 |
   | 2 | 📚 Git 指令集 | 命令列表、搜索、执行 |
   | 3 | 🌿 分支管理 | 分支树、创建/切换/合并/删除 |
   | 4 | ☁️ 远程仓库 | 远程列表、添加/编辑/删除 |
   | 5 | 🏷️ 标签管理 | 标签列表、创建/推送/删除 |
   | 6 | 🌳 分支依赖 | 依赖图渲染、交互 |
   | 7 | ⚠️ 冲突解决 | 冲突列表、解决功能 |
   | 8 | 📊 提交图谱 | 图谱渲染、缩放、拖拽 |
   | 9 | 📅 时间线 | 日历热力图、柱状图 |
   | 10 | 🔥 热力图 | 文件热力图、贡献者统计 |

3. **标签页切换测试**
   - 快速在各标签页之间切换
   - 验证切换流畅，无闪烁

4. **数据同步测试**
   - 在一个标签页执行操作
   - 切换到相关标签页
   - 验证数据同步更新

5. **主题适配测试**
   - 切换 VS Code 主题（浅色/深色）
   - 验证所有标签页正确适配

6. **响应式布局测试**
   - 调整控制面板宽度
   - 验证内容自适应

**验证清单**：
- [ ] 📋 快捷指令功能正常
- [ ] 📚 Git 指令集功能正常
- [ ] 🌿 分支管理功能正常
- [ ] ☁️ 远程仓库功能正常
- [ ] 🏷️ 标签管理功能正常
- [ ] 🌳 分支依赖功能正常
- [ ] ⚠️ 冲突解决功能正常
- [ ] 📊 提交图谱功能正常
- [ ] 📅 时间线功能正常
- [ ] 🔥 热力图功能正常
- [ ] 标签页切换流畅
- [ ] 数据同步正常
- [ ] 主题适配正常
- [ ] 响应式布局正常

---

### 2.7.10 端到端测试总结清单

**场景覆盖**
- [ ] 场景一：新项目初始化
- [ ] 场景二：日常开发工作流
- [ ] 场景三：多人协作模拟
- [ ] 场景四：版本发布流程
- [ ] 场景五：冲突解决完整流程
- [ ] 场景六：异常处理与恢复
- [ ] 场景七：跨平台兼容性
- [ ] 场景八：性能与压力测试
- [ ] 场景九：控制面板完整巡检

**关键功能验证**
- [ ] 仓库初始化流程完整
- [ ] 分支管理流程完整
- [ ] 远程同步流程完整
- [ ] 标签管理流程完整
- [ ] 冲突解决流程完整
- [ ] 异常处理友好
- [ ] 性能表现良好
- [ ] 10 个标签页功能正常

**回归测试建议**
- 每次发布前执行场景一到五
- 重大更新前执行全部场景
- 使用自动化脚本记录测试结果

# 3. 调试技巧

## 3.1 断点调试

```ts
context.subscriptions.push(
  vscode.commands.registerCommand('git-assistant.quickPush', async () => {
    debugger; // 在此设置断点
  })
);
```

## 3.2 调试控制台

- 查看 `console.log` 输出
- 执行表达式检查变量值

## 3.3 日志查看

- `Ctrl+Shift+U` → Git Assistant 日志
- 菜单：帮助 → 切换开发人员工具 → Console

## 3.4 Webview 调试

- 打开控制面板
- 右键 Webview → “打开开发者工具”
- 使用 Chrome DevTools 进行排查

# 4. 验证清单

**基础**

- [ ] 扩展激活（输出日志提示成功）
- [ ] 侧边栏显示分支/历史/冲突视图
- [ ] 命令面板列出所有 Git Assistant 命令
- [ ] 快捷键 `Ctrl+Alt+P/L/B` 正常
- [ ] 控制面板可加载

**功能覆盖**

- [ ] 控制面板 **10 个标签**内容与顺序正确
- [ ] Git 指令集与快捷指令历史面板可用
- [ ] 快捷指令历史可重新执行任一命令
- [ ] 远程仓库管理覆盖添加/编辑/删除
- [ ] 标签管理命令覆盖创建/推送/删除
- [ ] "初始化仓库 → 添加远程 → 初始提交" 可在空目录闭环执行

**Git 操作**

- [ ] 查看状态、切换/创建/合并分支
- [ ] 拉取/推送操作成功
- [ ] 提交历史列表展示完整信息
- [ ] 冲突检测在有冲突时提示并可打开冲突解决器

**UI**

- [ ] 分支树正确标记当前/远程分支
- [ ] 2D 提交图谱、热力图、分支依赖图、时间线视图数据正确
- [ ] 控制面板按钮、刷新与操作提示正常

**错误处理**

- [ ] 非 Git 仓库时提示初始化
- [ ] Git 操作失败时展示错误信息
- [ ] 网络/认证错误打印日志且不中断扩展

# 5. 常见问题

| 问题           | 排查思路                                                     |
| -------------- | ------------------------------------------------------------ |
| 扩展未激活     | 确认 `workspaceContains:.git` 生效、当前文件夹包含 `.git`，或执行初始化 |
| 命令不可用     | 可能不在 Git 仓库内，先运行 `git init` 或 Git Assistant: 初始化仓库 |
| 侧边栏图标丢失 | 右键活动栏 → 勾选 **Git Assistant**                          |
| Webview 空白   | 重新编译 `npm run compile`，确保 `dist/webview/webview.js` 存在 |
| TS 类型错误    | 执行 `npm install --save-dev @types/vscode @types/node`      |

# 6. 参考与附录

**调试输出示例**

```
[Extension Host] Git Assistant 扩展已激活
[Git Assistant] INFO: 开始执行快速推送
```

**性能验证指标**

- Extension Host 启动 < 500 ms
- 内存占用 < 50 MB

**下一步**

- 参阅 `docs/DEVELOPMENT.md`
- 在 `src/` 中修改功能
- 编写测试 / 优化性能
- `vsce package` 打包

**需要帮助？**

1. `Ctrl+Shift+U` → Git Assistant 日志
2. VS Code 开发者工具 Console
3. 文档：`README_CN.md` / `docs/DEVELOPMENT.md`

调试愉快！🎉